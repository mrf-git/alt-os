// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/api/os/machine/image/v0/api.proto

package v0

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VirtualizationType represents the type of virtualization for a
// machine to use.
type VirtualizationType int32

const (
	// No virtualization.
	VirtualizationType_VIRTUALIZATION_NONE VirtualizationType = 0
	// Use an external virtual machine.
	VirtualizationType_VIRTUALIZATION_EXT VirtualizationType = 1
	// Use full hardware virtualization.
	VirtualizationType_VIRTUALIZATION_HW VirtualizationType = 2
)

var VirtualizationType_name = map[int32]string{
	0: "VIRTUALIZATION_NONE",
	1: "VIRTUALIZATION_EXT",
	2: "VIRTUALIZATION_HW",
}

var VirtualizationType_value = map[string]int32{
	"VIRTUALIZATION_NONE": 0,
	"VIRTUALIZATION_EXT":  1,
	"VIRTUALIZATION_HW":   2,
}

func (x VirtualizationType) String() string {
	return proto.EnumName(VirtualizationType_name, int32(x))
}

func (VirtualizationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{0}
}

// PointingDeviceType represents a type of pointing device.
type PointingDeviceType int32

const (
	// No pointing device.
	PointingDeviceType_POINTING_NONE PointingDeviceType = 0
	// A mouse device.
	PointingDeviceType_POINTING_MOUSE PointingDeviceType = 1
	// A touch device.
	PointingDeviceType_POINTING_TOUCH PointingDeviceType = 2
)

var PointingDeviceType_name = map[int32]string{
	0: "POINTING_NONE",
	1: "POINTING_MOUSE",
	2: "POINTING_TOUCH",
}

var PointingDeviceType_value = map[string]int32{
	"POINTING_NONE":  0,
	"POINTING_MOUSE": 1,
	"POINTING_TOUCH": 2,
}

func (x PointingDeviceType) String() string {
	return proto.EnumName(PointingDeviceType_name, int32(x))
}

func (PointingDeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{1}
}

// StorageControllerType represents a type of storage controller.
type StorageControllerType int32

const (
	// Represents a null StorageControllerType.
	StorageControllerType_STORAGE_CONTROLLER_NONE StorageControllerType = 0
	// AHCI/SATA storage controller.
	StorageControllerType_STORAGE_CONTROLLER_SATA StorageControllerType = 1
	// USB storage controller.
	StorageControllerType_STORAGE_CONTROLLER_USB StorageControllerType = 2
)

var StorageControllerType_name = map[int32]string{
	0: "STORAGE_CONTROLLER_NONE",
	1: "STORAGE_CONTROLLER_SATA",
	2: "STORAGE_CONTROLLER_USB",
}

var StorageControllerType_value = map[string]int32{
	"STORAGE_CONTROLLER_NONE": 0,
	"STORAGE_CONTROLLER_SATA": 1,
	"STORAGE_CONTROLLER_USB":  2,
}

func (x StorageControllerType) String() string {
	return proto.EnumName(StorageControllerType_name, int32(x))
}

func (StorageControllerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{2}
}

// StorageDeviceType represents a type of storage device.
type StorageDeviceType int32

const (
	// Represents a null StorageDeviceType.
	StorageDeviceType_STORAGE_DEVICE_NONE StorageDeviceType = 0
	// A solid-state storage device.
	StorageDeviceType_STORAGE_DEVICE_SSD StorageDeviceType = 1
	// A magnetic hard disk device.
	StorageDeviceType_STORAGE_DEVICE_HDD StorageDeviceType = 2
	// An optical disk device.
	StorageDeviceType_STORAGE_DEVICE_OPTICAL StorageDeviceType = 3
)

var StorageDeviceType_name = map[int32]string{
	0: "STORAGE_DEVICE_NONE",
	1: "STORAGE_DEVICE_SSD",
	2: "STORAGE_DEVICE_HDD",
	3: "STORAGE_DEVICE_OPTICAL",
}

var StorageDeviceType_value = map[string]int32{
	"STORAGE_DEVICE_NONE":    0,
	"STORAGE_DEVICE_SSD":     1,
	"STORAGE_DEVICE_HDD":     2,
	"STORAGE_DEVICE_OPTICAL": 3,
}

func (x StorageDeviceType) String() string {
	return proto.EnumName(StorageDeviceType_name, int32(x))
}

func (StorageDeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{3}
}

// NetworkAttachmentType represents a type of attachment for a network adapter.
type NetworkAttachmentType int32

const (
	// The machine is directly attached to the network.
	NetworkAttachmentType_NET_ATTACHMENT_DIRECT NetworkAttachmentType = 0
	// The network is bridged to a VM host network.
	NetworkAttachmentType_NET_ATTACHMENT_BRIDGED NetworkAttachmentType = 1
	// The network is internal to the machine but allows outbound connections to a
	// VM host network using network address translation.
	NetworkAttachmentType_NET_ATTACHMENT_NAT_NETWORK NetworkAttachmentType = 2
)

var NetworkAttachmentType_name = map[int32]string{
	0: "NET_ATTACHMENT_DIRECT",
	1: "NET_ATTACHMENT_BRIDGED",
	2: "NET_ATTACHMENT_NAT_NETWORK",
}

var NetworkAttachmentType_value = map[string]int32{
	"NET_ATTACHMENT_DIRECT":      0,
	"NET_ATTACHMENT_BRIDGED":     1,
	"NET_ATTACHMENT_NAT_NETWORK": 2,
}

func (x NetworkAttachmentType) String() string {
	return proto.EnumName(NetworkAttachmentType_name, int32(x))
}

func (NetworkAttachmentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{4}
}

// ApiServeRequest specifies a VmmImageService.Serve call.
type ApiServeRequest struct {
	// The hostname for the API server to listen on.
	ApiHostname string `protobuf:"bytes,1,opt,name=api_hostname,json=apiHostname,proto3" json:"api_hostname,omitempty"`
	// The port for the API server to listen on.
	ApiPort uint32 `protobuf:"varint,2,opt,name=api_port,json=apiPort,proto3" json:"api_port,omitempty"`
	// The number of seconds to timeout the API request.
	ApiTimeout uint32 `protobuf:"varint,3,opt,name=api_timeout,json=apiTimeout,proto3" json:"api_timeout,omitempty"`
	// The path to the root directory of images.
	RootDir              string   `protobuf:"bytes,4,opt,name=root_dir,json=rootDir,proto3" json:"root_dir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApiServeRequest) Reset()      { *m = ApiServeRequest{} }
func (*ApiServeRequest) ProtoMessage() {}
func (*ApiServeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{0}
}
func (m *ApiServeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApiServeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApiServeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApiServeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApiServeRequest.Merge(m, src)
}
func (m *ApiServeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ApiServeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ApiServeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ApiServeRequest proto.InternalMessageInfo

func (m *ApiServeRequest) GetApiHostname() string {
	if m != nil {
		return m.ApiHostname
	}
	return ""
}

func (m *ApiServeRequest) GetApiPort() uint32 {
	if m != nil {
		return m.ApiPort
	}
	return 0
}

func (m *ApiServeRequest) GetApiTimeout() uint32 {
	if m != nil {
		return m.ApiTimeout
	}
	return 0
}

func (m *ApiServeRequest) GetRootDir() string {
	if m != nil {
		return m.RootDir
	}
	return ""
}

// ApiUnserveRequest specifies a VmmImageService.Unserve call.
type ApiUnserveRequest struct {
	// The hostname of the listening API server to operate on.
	ApiHostname string `protobuf:"bytes,1,opt,name=api_hostname,json=apiHostname,proto3" json:"api_hostname,omitempty"`
	// The port of the listening API server to operate on.
	ApiPort uint32 `protobuf:"varint,2,opt,name=api_port,json=apiPort,proto3" json:"api_port,omitempty"`
	// The number of seconds to timeout the API request.
	ApiTimeout           uint32   `protobuf:"varint,3,opt,name=api_timeout,json=apiTimeout,proto3" json:"api_timeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApiUnserveRequest) Reset()      { *m = ApiUnserveRequest{} }
func (*ApiUnserveRequest) ProtoMessage() {}
func (*ApiUnserveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{1}
}
func (m *ApiUnserveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApiUnserveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApiUnserveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApiUnserveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApiUnserveRequest.Merge(m, src)
}
func (m *ApiUnserveRequest) XXX_Size() int {
	return m.Size()
}
func (m *ApiUnserveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ApiUnserveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ApiUnserveRequest proto.InternalMessageInfo

func (m *ApiUnserveRequest) GetApiHostname() string {
	if m != nil {
		return m.ApiHostname
	}
	return ""
}

func (m *ApiUnserveRequest) GetApiPort() uint32 {
	if m != nil {
		return m.ApiPort
	}
	return 0
}

func (m *ApiUnserveRequest) GetApiTimeout() uint32 {
	if m != nil {
		return m.ApiTimeout
	}
	return 0
}

// CreateRequest specifies a VmmImageService.Create call.
type CreateRequest struct {
	// The hostname of the listening API server to operate on.
	ApiHostname string `protobuf:"bytes,1,opt,name=api_hostname,json=apiHostname,proto3" json:"api_hostname,omitempty"`
	// The port of the listening API server to operate on.
	ApiPort uint32 `protobuf:"varint,2,opt,name=api_port,json=apiPort,proto3" json:"api_port,omitempty"`
	// The number of seconds to timeout the API request.
	ApiTimeout uint32 `protobuf:"varint,3,opt,name=api_timeout,json=apiTimeout,proto3" json:"api_timeout,omitempty"`
	// The path to a file containing serialized VirtualMachines defining the images to create.
	// Not allowed if virtual_machines is set.
	VirtualMachinesFile string `protobuf:"bytes,4,opt,name=virtual_machines_file,json=virtualMachinesFile,proto3" json:"virtual_machines_file,omitempty"`
	// Objects defining the virtual_machines to create. Not allowed if virtual_machines_file is set.
	VirtualMachines      []*VirtualMachine `protobuf:"bytes,5,rep,name=virtual_machines,json=virtualMachines,proto3" json:"virtual_machines,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CreateRequest) Reset()      { *m = CreateRequest{} }
func (*CreateRequest) ProtoMessage() {}
func (*CreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{2}
}
func (m *CreateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateRequest.Merge(m, src)
}
func (m *CreateRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateRequest proto.InternalMessageInfo

func (m *CreateRequest) GetApiHostname() string {
	if m != nil {
		return m.ApiHostname
	}
	return ""
}

func (m *CreateRequest) GetApiPort() uint32 {
	if m != nil {
		return m.ApiPort
	}
	return 0
}

func (m *CreateRequest) GetApiTimeout() uint32 {
	if m != nil {
		return m.ApiTimeout
	}
	return 0
}

func (m *CreateRequest) GetVirtualMachinesFile() string {
	if m != nil {
		return m.VirtualMachinesFile
	}
	return ""
}

func (m *CreateRequest) GetVirtualMachines() []*VirtualMachine {
	if m != nil {
		return m.VirtualMachines
	}
	return nil
}

// VirtualMachine defines settings for a machine hosting OS containers.
type VirtualMachine struct {
	// The name of the subdirectory of the created virtual machine image
	// within the service's image root directory.
	ImageDir string `protobuf:"bytes,1,opt,name=image_dir,json=imageDir,proto3" json:"image_dir,omitempty"`
	// Total memory of the machine in bytes.
	Memory uint64 `protobuf:"varint,2,opt,name=memory,proto3" json:"memory,omitempty"`
	// Number of processors available.
	Processors uint64 `protobuf:"varint,3,opt,name=processors,proto3" json:"processors,omitempty"`
	// The type of virtualization to use.
	Virtualization VirtualizationType `protobuf:"varint,4,opt,name=virtualization,proto3,enum=os.machine.image.VirtualizationType" json:"virtualization,omitempty"`
	// Whether the hardware clock is UTC time.
	ClockUtc bool `protobuf:"varint,5,opt,name=clock_utc,json=clockUtc,proto3" json:"clock_utc,omitempty"`
	// Primary pointing device type.
	PointingDevice PointingDeviceType `protobuf:"varint,6,opt,name=pointing_device,json=pointingDevice,proto3,enum=os.machine.image.PointingDeviceType" json:"pointing_device,omitempty"`
	// Video settings for the machine.
	Video *Video `protobuf:"bytes,7,opt,name=video,proto3" json:"video,omitempty"`
	// Audio settings for the machine.
	Audio *Audio `protobuf:"bytes,8,opt,name=audio,proto3" json:"audio,omitempty"`
	// Storage devices attached to the machine.
	Storage []*StorageDevice `protobuf:"bytes,9,rep,name=storage,proto3" json:"storage,omitempty"`
	// Network devices attached to the machine.
	Network []*NetworkDevice `protobuf:"bytes,10,rep,name=network,proto3" json:"network,omitempty"`
	// Serial devices attached to the machine.
	Serial               []*SerialDevice `protobuf:"bytes,11,rep,name=serial,proto3" json:"serial,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *VirtualMachine) Reset()      { *m = VirtualMachine{} }
func (*VirtualMachine) ProtoMessage() {}
func (*VirtualMachine) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{3}
}
func (m *VirtualMachine) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualMachine) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VirtualMachine.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VirtualMachine) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualMachine.Merge(m, src)
}
func (m *VirtualMachine) XXX_Size() int {
	return m.Size()
}
func (m *VirtualMachine) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualMachine.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualMachine proto.InternalMessageInfo

func (m *VirtualMachine) GetImageDir() string {
	if m != nil {
		return m.ImageDir
	}
	return ""
}

func (m *VirtualMachine) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *VirtualMachine) GetProcessors() uint64 {
	if m != nil {
		return m.Processors
	}
	return 0
}

func (m *VirtualMachine) GetVirtualization() VirtualizationType {
	if m != nil {
		return m.Virtualization
	}
	return VirtualizationType_VIRTUALIZATION_NONE
}

func (m *VirtualMachine) GetClockUtc() bool {
	if m != nil {
		return m.ClockUtc
	}
	return false
}

func (m *VirtualMachine) GetPointingDevice() PointingDeviceType {
	if m != nil {
		return m.PointingDevice
	}
	return PointingDeviceType_POINTING_NONE
}

func (m *VirtualMachine) GetVideo() *Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *VirtualMachine) GetAudio() *Audio {
	if m != nil {
		return m.Audio
	}
	return nil
}

func (m *VirtualMachine) GetStorage() []*StorageDevice {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *VirtualMachine) GetNetwork() []*NetworkDevice {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *VirtualMachine) GetSerial() []*SerialDevice {
	if m != nil {
		return m.Serial
	}
	return nil
}

// Video defines machine video settings.
type Video struct {
	// Total video memory in bytes.
	Memory uint64 `protobuf:"varint,1,opt,name=memory,proto3" json:"memory,omitempty"`
	// Number of displays attached to the machine.
	Displays             uint64   `protobuf:"varint,2,opt,name=displays,proto3" json:"displays,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Video) Reset()      { *m = Video{} }
func (*Video) ProtoMessage() {}
func (*Video) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{4}
}
func (m *Video) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Video) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Video.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Video) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Video.Merge(m, src)
}
func (m *Video) XXX_Size() int {
	return m.Size()
}
func (m *Video) XXX_DiscardUnknown() {
	xxx_messageInfo_Video.DiscardUnknown(m)
}

var xxx_messageInfo_Video proto.InternalMessageInfo

func (m *Video) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Video) GetDisplays() uint64 {
	if m != nil {
		return m.Displays
	}
	return 0
}

// Audio defines machine audio settings.
type Audio struct {
	// Whether audio output is enabled.
	EnableOutput bool `protobuf:"varint,1,opt,name=enable_output,json=enableOutput,proto3" json:"enable_output,omitempty"`
	// Whether audio input is enabled.
	EnableInput          bool     `protobuf:"varint,2,opt,name=enable_input,json=enableInput,proto3" json:"enable_input,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Audio) Reset()      { *m = Audio{} }
func (*Audio) ProtoMessage() {}
func (*Audio) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{5}
}
func (m *Audio) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Audio) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Audio.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Audio) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Audio.Merge(m, src)
}
func (m *Audio) XXX_Size() int {
	return m.Size()
}
func (m *Audio) XXX_DiscardUnknown() {
	xxx_messageInfo_Audio.DiscardUnknown(m)
}

var xxx_messageInfo_Audio proto.InternalMessageInfo

func (m *Audio) GetEnableOutput() bool {
	if m != nil {
		return m.EnableOutput
	}
	return false
}

func (m *Audio) GetEnableInput() bool {
	if m != nil {
		return m.EnableInput
	}
	return false
}

// StorageDevice defines a storage device attached to the machine.
type StorageDevice struct {
	// The type of storage controller.
	Controller StorageControllerType `protobuf:"varint,1,opt,name=controller,proto3,enum=os.machine.image.StorageControllerType" json:"controller,omitempty"`
	// The type of device.
	Type StorageDeviceType `protobuf:"varint,2,opt,name=type,proto3,enum=os.machine.image.StorageDeviceType" json:"type,omitempty"`
	// Size of the storage in bytes.
	Size_ uint64 `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	// Whether this storage device is dynamically resizable.
	Dynamic              bool     `protobuf:"varint,4,opt,name=dynamic,proto3" json:"dynamic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageDevice) Reset()      { *m = StorageDevice{} }
func (*StorageDevice) ProtoMessage() {}
func (*StorageDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{6}
}
func (m *StorageDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDevice.Merge(m, src)
}
func (m *StorageDevice) XXX_Size() int {
	return m.Size()
}
func (m *StorageDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDevice.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDevice proto.InternalMessageInfo

func (m *StorageDevice) GetController() StorageControllerType {
	if m != nil {
		return m.Controller
	}
	return StorageControllerType_STORAGE_CONTROLLER_NONE
}

func (m *StorageDevice) GetType() StorageDeviceType {
	if m != nil {
		return m.Type
	}
	return StorageDeviceType_STORAGE_DEVICE_NONE
}

func (m *StorageDevice) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *StorageDevice) GetDynamic() bool {
	if m != nil {
		return m.Dynamic
	}
	return false
}

// NetworkDevice defines a network device attached to the machine.
type NetworkDevice struct {
	// The attachment type for the network.
	Type NetworkAttachmentType `protobuf:"varint,1,opt,name=type,proto3,enum=os.machine.image.NetworkAttachmentType" json:"type,omitempty"`
	// Whether to use virtio for virtualization. If false, this
	// represents a real network device or a PCNET device under VM.
	Virtio bool `protobuf:"varint,2,opt,name=virtio,proto3" json:"virtio,omitempty"`
	// The mac address of the device.
	Mac                  string   `protobuf:"bytes,3,opt,name=mac,proto3" json:"mac,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkDevice) Reset()      { *m = NetworkDevice{} }
func (*NetworkDevice) ProtoMessage() {}
func (*NetworkDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{7}
}
func (m *NetworkDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkDevice.Merge(m, src)
}
func (m *NetworkDevice) XXX_Size() int {
	return m.Size()
}
func (m *NetworkDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkDevice.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkDevice proto.InternalMessageInfo

func (m *NetworkDevice) GetType() NetworkAttachmentType {
	if m != nil {
		return m.Type
	}
	return NetworkAttachmentType_NET_ATTACHMENT_DIRECT
}

func (m *NetworkDevice) GetVirtio() bool {
	if m != nil {
		return m.Virtio
	}
	return false
}

func (m *NetworkDevice) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

// SerialDevice defines a 16550A-compatible UART serial device attached to the machine.
type SerialDevice struct {
	// The serial I/O port.
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// The interrupt number to use.
	Irq                  uint32   `protobuf:"varint,2,opt,name=irq,proto3" json:"irq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SerialDevice) Reset()      { *m = SerialDevice{} }
func (*SerialDevice) ProtoMessage() {}
func (*SerialDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_2ca3fe20336776bf, []int{8}
}
func (m *SerialDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SerialDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SerialDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SerialDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SerialDevice.Merge(m, src)
}
func (m *SerialDevice) XXX_Size() int {
	return m.Size()
}
func (m *SerialDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_SerialDevice.DiscardUnknown(m)
}

var xxx_messageInfo_SerialDevice proto.InternalMessageInfo

func (m *SerialDevice) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SerialDevice) GetIrq() uint32 {
	if m != nil {
		return m.Irq
	}
	return 0
}

func init() {
	proto.RegisterEnum("os.machine.image.VirtualizationType", VirtualizationType_name, VirtualizationType_value)
	proto.RegisterEnum("os.machine.image.PointingDeviceType", PointingDeviceType_name, PointingDeviceType_value)
	proto.RegisterEnum("os.machine.image.StorageControllerType", StorageControllerType_name, StorageControllerType_value)
	proto.RegisterEnum("os.machine.image.StorageDeviceType", StorageDeviceType_name, StorageDeviceType_value)
	proto.RegisterEnum("os.machine.image.NetworkAttachmentType", NetworkAttachmentType_name, NetworkAttachmentType_value)
	proto.RegisterType((*ApiServeRequest)(nil), "os.machine.image.ApiServeRequest")
	proto.RegisterType((*ApiUnserveRequest)(nil), "os.machine.image.ApiUnserveRequest")
	proto.RegisterType((*CreateRequest)(nil), "os.machine.image.CreateRequest")
	proto.RegisterType((*VirtualMachine)(nil), "os.machine.image.VirtualMachine")
	proto.RegisterType((*Video)(nil), "os.machine.image.Video")
	proto.RegisterType((*Audio)(nil), "os.machine.image.Audio")
	proto.RegisterType((*StorageDevice)(nil), "os.machine.image.StorageDevice")
	proto.RegisterType((*NetworkDevice)(nil), "os.machine.image.NetworkDevice")
	proto.RegisterType((*SerialDevice)(nil), "os.machine.image.SerialDevice")
}

func init() {
	proto.RegisterFile("pkg/api/os/machine/image/v0/api.proto", fileDescriptor_2ca3fe20336776bf)
}

var fileDescriptor_2ca3fe20336776bf = []byte{
	// 1081 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xc1, 0x6f, 0xe3, 0xc4,
	0x17, 0xae, 0xd3, 0x34, 0x4d, 0x5f, 0x37, 0xa9, 0x3b, 0xfb, 0x6b, 0xd7, 0x9b, 0x4a, 0xde, 0x6c,
	0xfa, 0x43, 0x54, 0x95, 0x36, 0x41, 0x01, 0x81, 0xd0, 0x5e, 0x70, 0x13, 0xd3, 0x46, 0x6d, 0xe3,
	0xca, 0x71, 0xba, 0x68, 0x85, 0x64, 0xb9, 0xc9, 0x6c, 0x3a, 0xaa, 0xed, 0xf1, 0xda, 0x93, 0x40,
	0xf6, 0xc4, 0x9d, 0x7f, 0x04, 0x89, 0x3f, 0x82, 0x2b, 0x47, 0x8e, 0x1c, 0x69, 0xcf, 0x48, 0x70,
	0xe4, 0x88, 0x66, 0x3c, 0x29, 0x49, 0x9a, 0xc0, 0x6d, 0x6f, 0x9e, 0xef, 0x7d, 0xdf, 0x7b, 0x6f,
	0xe6, 0xbd, 0x19, 0x3f, 0xf8, 0x20, 0xba, 0x19, 0xd4, 0xbc, 0x88, 0xd4, 0x68, 0x52, 0x0b, 0xbc,
	0xde, 0x35, 0x09, 0x71, 0x8d, 0x04, 0xde, 0x00, 0xd7, 0x46, 0x1f, 0x71, 0xbc, 0x1a, 0xc5, 0x94,
	0x51, 0xa4, 0xd2, 0xa4, 0x2a, 0xcd, 0x55, 0x61, 0x2e, 0xfd, 0x6f, 0x40, 0x07, 0x54, 0x18, 0x6b,
	0xfc, 0x2b, 0xe5, 0x95, 0xf6, 0x06, 0x94, 0x0e, 0x7c, 0x5c, 0x13, 0xab, 0xab, 0xe1, 0x9b, 0x1a,
	0x0e, 0x22, 0x36, 0x4e, 0x8d, 0x95, 0xef, 0x15, 0xd8, 0x32, 0x22, 0xd2, 0xc1, 0xf1, 0x08, 0xdb,
	0xf8, 0xed, 0x10, 0x27, 0x0c, 0x3d, 0x87, 0x47, 0x5e, 0x44, 0xdc, 0x6b, 0x9a, 0xb0, 0xd0, 0x0b,
	0xb0, 0xa6, 0x94, 0x95, 0x83, 0x0d, 0x7b, 0xd3, 0x8b, 0xc8, 0x89, 0x84, 0xd0, 0x53, 0xc8, 0x73,
	0x4a, 0x44, 0x63, 0xa6, 0x65, 0xca, 0xca, 0x41, 0xc1, 0x5e, 0xf7, 0x22, 0x72, 0x41, 0x63, 0x86,
	0x9e, 0x01, 0x67, 0xba, 0x8c, 0x04, 0x98, 0x0e, 0x99, 0xb6, 0x2a, 0xac, 0xe0, 0x45, 0xc4, 0x49,
	0x11, 0xae, 0x8d, 0x29, 0x65, 0x6e, 0x9f, 0xc4, 0x5a, 0x56, 0xb8, 0x5e, 0xe7, 0xeb, 0x26, 0x89,
	0x2b, 0x31, 0x6c, 0x1b, 0x11, 0xe9, 0x86, 0xc9, 0xfb, 0x4b, 0xa7, 0xf2, 0x87, 0x02, 0x85, 0x46,
	0x8c, 0x3d, 0xf6, 0xbe, 0xf6, 0x5f, 0x87, 0x9d, 0x11, 0x89, 0xd9, 0xd0, 0xf3, 0x5d, 0x59, 0xbe,
	0xc4, 0x7d, 0x43, 0x7c, 0x2c, 0x0f, 0xe3, 0xb1, 0x34, 0x9e, 0x4b, 0xdb, 0x97, 0xc4, 0xc7, 0xe8,
	0x14, 0xd4, 0x79, 0x8d, 0xb6, 0x56, 0x5e, 0x3d, 0xd8, 0xac, 0x97, 0xab, 0xf3, 0x6d, 0x50, 0xbd,
	0x9c, 0x71, 0x60, 0x6f, 0xcd, 0x39, 0xac, 0xfc, 0x98, 0x85, 0xe2, 0x2c, 0x07, 0xed, 0xc1, 0x86,
	0xd0, 0x8a, 0xa2, 0xa4, 0xfb, 0xcd, 0x0b, 0xa0, 0x49, 0x62, 0xb4, 0x0b, 0xb9, 0x00, 0x07, 0x34,
	0x1e, 0x8b, 0xad, 0x66, 0x6d, 0xb9, 0x42, 0x3a, 0x40, 0x14, 0xd3, 0x1e, 0x4e, 0x12, 0x1a, 0x27,
	0x62, 0xa3, 0x59, 0x7b, 0x0a, 0x41, 0x67, 0x50, 0x94, 0xa1, 0xc9, 0x3b, 0x8f, 0x11, 0x1a, 0x8a,
	0x1d, 0x16, 0xeb, 0xff, 0x5f, 0x9a, 0xb2, 0xe4, 0x39, 0xe3, 0x08, 0xdb, 0x73, 0x5a, 0x9e, 0x62,
	0xcf, 0xa7, 0xbd, 0x1b, 0x77, 0xc8, 0x7a, 0xda, 0x5a, 0x59, 0x39, 0xc8, 0xdb, 0x79, 0x01, 0x74,
	0x59, 0x0f, 0x9d, 0xc3, 0x56, 0x44, 0x49, 0xc8, 0x48, 0x38, 0x70, 0xfb, 0x78, 0x44, 0x7a, 0x58,
	0xcb, 0x2d, 0x8b, 0x75, 0x21, 0x89, 0x4d, 0xc1, 0x4b, 0x63, 0x45, 0x33, 0x18, 0x7a, 0x01, 0x6b,
	0x23, 0xd2, 0xc7, 0x54, 0x5b, 0x2f, 0x2b, 0x07, 0x9b, 0xf5, 0x27, 0x8b, 0x12, 0xee, 0x63, 0x6a,
	0xa7, 0x2c, 0x4e, 0xf7, 0x86, 0x7d, 0x42, 0xb5, 0xfc, 0x32, 0xba, 0xc1, 0xcd, 0x76, 0xca, 0x42,
	0x9f, 0xc3, 0x7a, 0xc2, 0x68, 0xec, 0x0d, 0xb0, 0xb6, 0x21, 0x6a, 0xf8, 0xec, 0xa1, 0xa0, 0x93,
	0x12, 0xd2, 0x7c, 0xec, 0x09, 0x9f, 0x4b, 0x43, 0xcc, 0xbe, 0xa1, 0xf1, 0x8d, 0x06, 0xcb, 0xa4,
	0xed, 0x94, 0x30, 0x91, 0x4a, 0x3e, 0xfa, 0x14, 0x72, 0x09, 0x8e, 0x89, 0xe7, 0x6b, 0x9b, 0x42,
	0xa9, 0x2f, 0x08, 0x2a, 0xec, 0x52, 0x28, 0xd9, 0x95, 0x97, 0xb0, 0x26, 0x36, 0x3b, 0xd5, 0x06,
	0xca, 0x4c, 0x1b, 0x94, 0x20, 0xdf, 0x27, 0x49, 0xe4, 0x7b, 0xe3, 0x44, 0x36, 0xc8, 0xfd, 0xba,
	0x62, 0xc1, 0x9a, 0xd8, 0x3a, 0xda, 0x87, 0x02, 0x0e, 0xbd, 0x2b, 0x1f, 0xbb, 0x74, 0xc8, 0xa2,
	0x21, 0x13, 0x3e, 0xf2, 0xf6, 0xa3, 0x14, 0xb4, 0x04, 0xc6, 0x2f, 0x9e, 0x24, 0x91, 0x90, 0x73,
	0x32, 0x82, 0xb3, 0x99, 0x62, 0x2d, 0x0e, 0x55, 0x7e, 0x52, 0xa0, 0x30, 0x73, 0x36, 0xe8, 0x18,
	0xa0, 0x47, 0x43, 0x16, 0x53, 0xdf, 0xc7, 0x69, 0xef, 0x16, 0xeb, 0x1f, 0x2e, 0x3d, 0xd0, 0xc6,
	0x3d, 0x55, 0x14, 0x7e, 0x4a, 0x8a, 0x3e, 0x83, 0x2c, 0x1b, 0x47, 0x58, 0x44, 0x2d, 0xd6, 0xf7,
	0xff, 0xa3, 0x26, 0x42, 0x2e, 0x04, 0x08, 0x41, 0x36, 0x21, 0xef, 0xb0, 0xbc, 0x01, 0xe2, 0x1b,
	0x69, 0xb0, 0xde, 0x1f, 0x87, 0x5e, 0x40, 0x7a, 0xa2, 0xe9, 0xf3, 0xf6, 0x64, 0x59, 0x19, 0x41,
	0x61, 0xa6, 0x42, 0xe8, 0xa5, 0x8c, 0xbb, 0x34, 0x75, 0x49, 0x37, 0x18, 0xf3, 0x7a, 0xd7, 0x01,
	0x0e, 0xd9, 0x54, 0xec, 0x5d, 0xc8, 0xf1, 0x7b, 0x42, 0xa8, 0x3c, 0x2c, 0xb9, 0x42, 0x2a, 0xac,
	0x06, 0x5e, 0x4f, 0xa4, 0xb4, 0x61, 0xf3, 0xcf, 0xca, 0x27, 0xf0, 0x68, 0xba, 0xbe, 0x3c, 0x6b,
	0xf1, 0x7c, 0x29, 0xe2, 0x81, 0x12, 0xdf, 0x5c, 0x45, 0xe2, 0xb7, 0xf2, 0x45, 0xe3, 0x9f, 0x87,
	0x5f, 0x03, 0x7a, 0x78, 0x37, 0xd1, 0x13, 0x78, 0x7c, 0xd9, 0xb2, 0x9d, 0xae, 0x71, 0xd6, 0x7a,
	0x6d, 0x38, 0x2d, 0xab, 0xed, 0xb6, 0xad, 0xb6, 0xa9, 0xae, 0xa0, 0x5d, 0x40, 0x73, 0x06, 0xf3,
	0x2b, 0x47, 0x55, 0xd0, 0x0e, 0x6c, 0xcf, 0xe1, 0x27, 0xaf, 0xd4, 0xcc, 0xa1, 0x05, 0xe8, 0xe1,
	0x6d, 0x44, 0xdb, 0x50, 0xb8, 0xb0, 0x5a, 0x6d, 0xa7, 0xd5, 0x3e, 0x9e, 0xf8, 0x45, 0x50, 0xbc,
	0x87, 0xce, 0xad, 0x6e, 0xc7, 0x54, 0x95, 0x19, 0xcc, 0xb1, 0xba, 0x8d, 0x13, 0x35, 0x73, 0x18,
	0xc0, 0xce, 0xc2, 0x42, 0xa3, 0x3d, 0x78, 0xd2, 0x71, 0x2c, 0xdb, 0x38, 0x36, 0xdd, 0x86, 0xd5,
	0x76, 0x6c, 0xeb, 0xec, 0xcc, 0xb4, 0x27, 0xde, 0x17, 0x1b, 0x3b, 0x86, 0x63, 0xa8, 0x0a, 0x2a,
	0xc1, 0xee, 0x02, 0x63, 0xb7, 0x73, 0xa4, 0x66, 0x0e, 0xbf, 0x85, 0xed, 0x07, 0x4d, 0xc1, 0x0f,
	0x67, 0x22, 0x68, 0x9a, 0x97, 0xad, 0x86, 0x39, 0x75, 0x38, 0x73, 0x86, 0x4e, 0xa7, 0xa9, 0x2a,
	0x0b, 0xf0, 0x93, 0x66, 0x53, 0xcd, 0x4c, 0x47, 0x96, 0xb8, 0x75, 0xe1, 0xb4, 0x1a, 0xc6, 0x99,
	0xba, 0x7a, 0x18, 0xc2, 0xce, 0xc2, 0xb6, 0x40, 0x4f, 0x61, 0xa7, 0x6d, 0x3a, 0xae, 0xe1, 0x38,
	0x46, 0xe3, 0xe4, 0xdc, 0x6c, 0x3b, 0x6e, 0xb3, 0x65, 0x9b, 0x0d, 0x47, 0x5d, 0xe1, 0xfe, 0xe6,
	0x4c, 0x47, 0x76, 0xab, 0x79, 0x6c, 0xf2, 0x1c, 0x74, 0x28, 0xcd, 0xd9, 0xda, 0x86, 0xe3, 0xb6,
	0x4d, 0xe7, 0x95, 0x65, 0x9f, 0xaa, 0x99, 0xfa, 0xef, 0x0a, 0x6c, 0x5d, 0x06, 0x41, 0x8b, 0x37,
	0x24, 0x1f, 0x16, 0xd2, 0x9b, 0x97, 0x9f, 0x8c, 0x0e, 0xe8, 0xf9, 0x82, 0x37, 0x6f, 0x76, 0xac,
	0x28, 0xed, 0x56, 0xd3, 0x41, 0xa4, 0x3a, 0x19, 0x44, 0xaa, 0x26, 0x1f, 0x44, 0x2a, 0x2b, 0xe8,
	0x14, 0xe0, 0x9f, 0xdf, 0x3e, 0xda, 0x5f, 0xe8, 0x6a, 0x76, 0x28, 0xf8, 0x17, 0x67, 0x0d, 0xc8,
	0xa5, 0xbf, 0x73, 0xb4, 0xe0, 0x6d, 0x9c, 0xf9, 0xd1, 0x2f, 0x77, 0x72, 0xf4, 0xc5, 0xaf, 0xb7,
	0xfa, 0xca, 0x9f, 0xb7, 0xba, 0xf2, 0xd7, 0xad, 0xbe, 0xf2, 0xdd, 0x9d, 0xae, 0xfc, 0x70, 0xa7,
	0x2b, 0x3f, 0xdf, 0xe9, 0xca, 0x2f, 0x77, 0xba, 0xf2, 0xdb, 0x9d, 0xae, 0xbc, 0xd6, 0x3d, 0x9f,
	0xbd, 0xa0, 0xc9, 0xb2, 0x39, 0xed, 0x2a, 0x27, 0x7c, 0x7e, 0xfc, 0x77, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x73, 0x5f, 0x14, 0x33, 0xcd, 0x09, 0x00, 0x00,
}

func (this *ApiServeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApiServeRequest)
	if !ok {
		that2, ok := that.(ApiServeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiHostname != that1.ApiHostname {
		return false
	}
	if this.ApiPort != that1.ApiPort {
		return false
	}
	if this.ApiTimeout != that1.ApiTimeout {
		return false
	}
	if this.RootDir != that1.RootDir {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ApiUnserveRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApiUnserveRequest)
	if !ok {
		that2, ok := that.(ApiUnserveRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiHostname != that1.ApiHostname {
		return false
	}
	if this.ApiPort != that1.ApiPort {
		return false
	}
	if this.ApiTimeout != that1.ApiTimeout {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CreateRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateRequest)
	if !ok {
		that2, ok := that.(CreateRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiHostname != that1.ApiHostname {
		return false
	}
	if this.ApiPort != that1.ApiPort {
		return false
	}
	if this.ApiTimeout != that1.ApiTimeout {
		return false
	}
	if this.VirtualMachinesFile != that1.VirtualMachinesFile {
		return false
	}
	if len(this.VirtualMachines) != len(that1.VirtualMachines) {
		return false
	}
	for i := range this.VirtualMachines {
		if !this.VirtualMachines[i].Equal(that1.VirtualMachines[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VirtualMachine) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMachine)
	if !ok {
		that2, ok := that.(VirtualMachine)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ImageDir != that1.ImageDir {
		return false
	}
	if this.Memory != that1.Memory {
		return false
	}
	if this.Processors != that1.Processors {
		return false
	}
	if this.Virtualization != that1.Virtualization {
		return false
	}
	if this.ClockUtc != that1.ClockUtc {
		return false
	}
	if this.PointingDevice != that1.PointingDevice {
		return false
	}
	if !this.Video.Equal(that1.Video) {
		return false
	}
	if !this.Audio.Equal(that1.Audio) {
		return false
	}
	if len(this.Storage) != len(that1.Storage) {
		return false
	}
	for i := range this.Storage {
		if !this.Storage[i].Equal(that1.Storage[i]) {
			return false
		}
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if len(this.Serial) != len(that1.Serial) {
		return false
	}
	for i := range this.Serial {
		if !this.Serial[i].Equal(that1.Serial[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Video) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Video)
	if !ok {
		that2, ok := that.(Video)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Memory != that1.Memory {
		return false
	}
	if this.Displays != that1.Displays {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Audio) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Audio)
	if !ok {
		that2, ok := that.(Audio)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EnableOutput != that1.EnableOutput {
		return false
	}
	if this.EnableInput != that1.EnableInput {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *StorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDevice)
	if !ok {
		that2, ok := that.(StorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Controller != that1.Controller {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.Dynamic != that1.Dynamic {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *NetworkDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkDevice)
	if !ok {
		that2, ok := that.(NetworkDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Virtio != that1.Virtio {
		return false
	}
	if this.Mac != that1.Mac {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SerialDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SerialDevice)
	if !ok {
		that2, ok := that.(SerialDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Irq != that1.Irq {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ApiServeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v0.ApiServeRequest{")
	s = append(s, "ApiHostname: "+fmt.Sprintf("%#v", this.ApiHostname)+",\n")
	s = append(s, "ApiPort: "+fmt.Sprintf("%#v", this.ApiPort)+",\n")
	s = append(s, "ApiTimeout: "+fmt.Sprintf("%#v", this.ApiTimeout)+",\n")
	s = append(s, "RootDir: "+fmt.Sprintf("%#v", this.RootDir)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ApiUnserveRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v0.ApiUnserveRequest{")
	s = append(s, "ApiHostname: "+fmt.Sprintf("%#v", this.ApiHostname)+",\n")
	s = append(s, "ApiPort: "+fmt.Sprintf("%#v", this.ApiPort)+",\n")
	s = append(s, "ApiTimeout: "+fmt.Sprintf("%#v", this.ApiTimeout)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&v0.CreateRequest{")
	s = append(s, "ApiHostname: "+fmt.Sprintf("%#v", this.ApiHostname)+",\n")
	s = append(s, "ApiPort: "+fmt.Sprintf("%#v", this.ApiPort)+",\n")
	s = append(s, "ApiTimeout: "+fmt.Sprintf("%#v", this.ApiTimeout)+",\n")
	s = append(s, "VirtualMachinesFile: "+fmt.Sprintf("%#v", this.VirtualMachinesFile)+",\n")
	if this.VirtualMachines != nil {
		s = append(s, "VirtualMachines: "+fmt.Sprintf("%#v", this.VirtualMachines)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VirtualMachine) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&v0.VirtualMachine{")
	s = append(s, "ImageDir: "+fmt.Sprintf("%#v", this.ImageDir)+",\n")
	s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	s = append(s, "Processors: "+fmt.Sprintf("%#v", this.Processors)+",\n")
	s = append(s, "Virtualization: "+fmt.Sprintf("%#v", this.Virtualization)+",\n")
	s = append(s, "ClockUtc: "+fmt.Sprintf("%#v", this.ClockUtc)+",\n")
	s = append(s, "PointingDevice: "+fmt.Sprintf("%#v", this.PointingDevice)+",\n")
	if this.Video != nil {
		s = append(s, "Video: "+fmt.Sprintf("%#v", this.Video)+",\n")
	}
	if this.Audio != nil {
		s = append(s, "Audio: "+fmt.Sprintf("%#v", this.Audio)+",\n")
	}
	if this.Storage != nil {
		s = append(s, "Storage: "+fmt.Sprintf("%#v", this.Storage)+",\n")
	}
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.Serial != nil {
		s = append(s, "Serial: "+fmt.Sprintf("%#v", this.Serial)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Video) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v0.Video{")
	s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	s = append(s, "Displays: "+fmt.Sprintf("%#v", this.Displays)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Audio) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v0.Audio{")
	s = append(s, "EnableOutput: "+fmt.Sprintf("%#v", this.EnableOutput)+",\n")
	s = append(s, "EnableInput: "+fmt.Sprintf("%#v", this.EnableInput)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v0.StorageDevice{")
	s = append(s, "Controller: "+fmt.Sprintf("%#v", this.Controller)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "Dynamic: "+fmt.Sprintf("%#v", this.Dynamic)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v0.NetworkDevice{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Virtio: "+fmt.Sprintf("%#v", this.Virtio)+",\n")
	s = append(s, "Mac: "+fmt.Sprintf("%#v", this.Mac)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SerialDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v0.SerialDevice{")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Irq: "+fmt.Sprintf("%#v", this.Irq)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VmmImageServiceClient is the client API for VmmImageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VmmImageServiceClient interface {
	// ApiServe enables the virtual machine image service api according to the given configuration.
	ApiServe(ctx context.Context, in *ApiServeRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// ApiUnserve disables the virtual machine image service api.
	ApiUnserve(ctx context.Context, in *ApiUnserveRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// Create generates a new image in a subdirectory of the image service root directory.
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*types.Empty, error)
}

type vmmImageServiceClient struct {
	cc *grpc.ClientConn
}

func NewVmmImageServiceClient(cc *grpc.ClientConn) VmmImageServiceClient {
	return &vmmImageServiceClient{cc}
}

func (c *vmmImageServiceClient) ApiServe(ctx context.Context, in *ApiServeRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/os.machine.image.VmmImageService/ApiServe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmmImageServiceClient) ApiUnserve(ctx context.Context, in *ApiUnserveRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/os.machine.image.VmmImageService/ApiUnserve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmmImageServiceClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/os.machine.image.VmmImageService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VmmImageServiceServer is the server API for VmmImageService service.
type VmmImageServiceServer interface {
	// ApiServe enables the virtual machine image service api according to the given configuration.
	ApiServe(context.Context, *ApiServeRequest) (*types.Empty, error)
	// ApiUnserve disables the virtual machine image service api.
	ApiUnserve(context.Context, *ApiUnserveRequest) (*types.Empty, error)
	// Create generates a new image in a subdirectory of the image service root directory.
	Create(context.Context, *CreateRequest) (*types.Empty, error)
}

// UnimplementedVmmImageServiceServer can be embedded to have forward compatible implementations.
type UnimplementedVmmImageServiceServer struct {
}

func (*UnimplementedVmmImageServiceServer) ApiServe(ctx context.Context, req *ApiServeRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiServe not implemented")
}
func (*UnimplementedVmmImageServiceServer) ApiUnserve(ctx context.Context, req *ApiUnserveRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiUnserve not implemented")
}
func (*UnimplementedVmmImageServiceServer) Create(ctx context.Context, req *CreateRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}

func RegisterVmmImageServiceServer(s *grpc.Server, srv VmmImageServiceServer) {
	s.RegisterService(&_VmmImageService_serviceDesc, srv)
}

func _VmmImageService_ApiServe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiServeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmmImageServiceServer).ApiServe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/os.machine.image.VmmImageService/ApiServe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmmImageServiceServer).ApiServe(ctx, req.(*ApiServeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmmImageService_ApiUnserve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiUnserveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmmImageServiceServer).ApiUnserve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/os.machine.image.VmmImageService/ApiUnserve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmmImageServiceServer).ApiUnserve(ctx, req.(*ApiUnserveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmmImageService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmmImageServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/os.machine.image.VmmImageService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmmImageServiceServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VmmImageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "os.machine.image.VmmImageService",
	HandlerType: (*VmmImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ApiServe",
			Handler:    _VmmImageService_ApiServe_Handler,
		},
		{
			MethodName: "ApiUnserve",
			Handler:    _VmmImageService_ApiUnserve_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _VmmImageService_Create_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/api/os/machine/image/v0/api.proto",
}

func (m *ApiServeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiServeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApiServeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RootDir) > 0 {
		i -= len(m.RootDir)
		copy(dAtA[i:], m.RootDir)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RootDir)))
		i--
		dAtA[i] = 0x22
	}
	if m.ApiTimeout != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ApiTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.ApiPort != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ApiPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ApiHostname) > 0 {
		i -= len(m.ApiHostname)
		copy(dAtA[i:], m.ApiHostname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ApiHostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApiUnserveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiUnserveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApiUnserveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiTimeout != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ApiTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.ApiPort != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ApiPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ApiHostname) > 0 {
		i -= len(m.ApiHostname)
		copy(dAtA[i:], m.ApiHostname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ApiHostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VirtualMachines) > 0 {
		for iNdEx := len(m.VirtualMachines) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualMachines[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.VirtualMachinesFile) > 0 {
		i -= len(m.VirtualMachinesFile)
		copy(dAtA[i:], m.VirtualMachinesFile)
		i = encodeVarintApi(dAtA, i, uint64(len(m.VirtualMachinesFile)))
		i--
		dAtA[i] = 0x22
	}
	if m.ApiTimeout != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ApiTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.ApiPort != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ApiPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ApiHostname) > 0 {
		i -= len(m.ApiHostname)
		copy(dAtA[i:], m.ApiHostname)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ApiHostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VirtualMachine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualMachine) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualMachine) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Serial) > 0 {
		for iNdEx := len(m.Serial) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Serial[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Storage) > 0 {
		for iNdEx := len(m.Storage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Storage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Audio != nil {
		{
			size, err := m.Audio.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PointingDevice != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PointingDevice))
		i--
		dAtA[i] = 0x30
	}
	if m.ClockUtc {
		i--
		if m.ClockUtc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Virtualization != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Virtualization))
		i--
		dAtA[i] = 0x20
	}
	if m.Processors != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Processors))
		i--
		dAtA[i] = 0x18
	}
	if m.Memory != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ImageDir) > 0 {
		i -= len(m.ImageDir)
		copy(dAtA[i:], m.ImageDir)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ImageDir)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Video) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Video) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Video) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Displays != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Displays))
		i--
		dAtA[i] = 0x10
	}
	if m.Memory != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Audio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Audio) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Audio) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnableInput {
		i--
		if m.EnableInput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.EnableOutput {
		i--
		if m.EnableOutput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StorageDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dynamic {
		i--
		if m.Dynamic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Size_ != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Controller != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Controller))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Virtio {
		i--
		if m.Virtio {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SerialDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SerialDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SerialDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Irq != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Irq))
		i--
		dAtA[i] = 0x10
	}
	if m.Port != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ApiServeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiHostname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ApiPort != 0 {
		n += 1 + sovApi(uint64(m.ApiPort))
	}
	if m.ApiTimeout != 0 {
		n += 1 + sovApi(uint64(m.ApiTimeout))
	}
	l = len(m.RootDir)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ApiUnserveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiHostname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ApiPort != 0 {
		n += 1 + sovApi(uint64(m.ApiPort))
	}
	if m.ApiTimeout != 0 {
		n += 1 + sovApi(uint64(m.ApiTimeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiHostname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ApiPort != 0 {
		n += 1 + sovApi(uint64(m.ApiPort))
	}
	if m.ApiTimeout != 0 {
		n += 1 + sovApi(uint64(m.ApiTimeout))
	}
	l = len(m.VirtualMachinesFile)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.VirtualMachines) > 0 {
		for _, e := range m.VirtualMachines {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VirtualMachine) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImageDir)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Memory != 0 {
		n += 1 + sovApi(uint64(m.Memory))
	}
	if m.Processors != 0 {
		n += 1 + sovApi(uint64(m.Processors))
	}
	if m.Virtualization != 0 {
		n += 1 + sovApi(uint64(m.Virtualization))
	}
	if m.ClockUtc {
		n += 2
	}
	if m.PointingDevice != 0 {
		n += 1 + sovApi(uint64(m.PointingDevice))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Audio != nil {
		l = m.Audio.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Storage) > 0 {
		for _, e := range m.Storage {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Serial) > 0 {
		for _, e := range m.Serial {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Video) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Memory != 0 {
		n += 1 + sovApi(uint64(m.Memory))
	}
	if m.Displays != 0 {
		n += 1 + sovApi(uint64(m.Displays))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Audio) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableOutput {
		n += 2
	}
	if m.EnableInput {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Controller != 0 {
		n += 1 + sovApi(uint64(m.Controller))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	if m.Dynamic {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Virtio {
		n += 2
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SerialDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovApi(uint64(m.Port))
	}
	if m.Irq != 0 {
		n += 1 + sovApi(uint64(m.Irq))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ApiServeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApiServeRequest{`,
		`ApiHostname:` + fmt.Sprintf("%v", this.ApiHostname) + `,`,
		`ApiPort:` + fmt.Sprintf("%v", this.ApiPort) + `,`,
		`ApiTimeout:` + fmt.Sprintf("%v", this.ApiTimeout) + `,`,
		`RootDir:` + fmt.Sprintf("%v", this.RootDir) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApiUnserveRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApiUnserveRequest{`,
		`ApiHostname:` + fmt.Sprintf("%v", this.ApiHostname) + `,`,
		`ApiPort:` + fmt.Sprintf("%v", this.ApiPort) + `,`,
		`ApiTimeout:` + fmt.Sprintf("%v", this.ApiTimeout) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVirtualMachines := "[]*VirtualMachine{"
	for _, f := range this.VirtualMachines {
		repeatedStringForVirtualMachines += strings.Replace(f.String(), "VirtualMachine", "VirtualMachine", 1) + ","
	}
	repeatedStringForVirtualMachines += "}"
	s := strings.Join([]string{`&CreateRequest{`,
		`ApiHostname:` + fmt.Sprintf("%v", this.ApiHostname) + `,`,
		`ApiPort:` + fmt.Sprintf("%v", this.ApiPort) + `,`,
		`ApiTimeout:` + fmt.Sprintf("%v", this.ApiTimeout) + `,`,
		`VirtualMachinesFile:` + fmt.Sprintf("%v", this.VirtualMachinesFile) + `,`,
		`VirtualMachines:` + repeatedStringForVirtualMachines + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualMachine) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStorage := "[]*StorageDevice{"
	for _, f := range this.Storage {
		repeatedStringForStorage += strings.Replace(f.String(), "StorageDevice", "StorageDevice", 1) + ","
	}
	repeatedStringForStorage += "}"
	repeatedStringForNetwork := "[]*NetworkDevice{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(f.String(), "NetworkDevice", "NetworkDevice", 1) + ","
	}
	repeatedStringForNetwork += "}"
	repeatedStringForSerial := "[]*SerialDevice{"
	for _, f := range this.Serial {
		repeatedStringForSerial += strings.Replace(f.String(), "SerialDevice", "SerialDevice", 1) + ","
	}
	repeatedStringForSerial += "}"
	s := strings.Join([]string{`&VirtualMachine{`,
		`ImageDir:` + fmt.Sprintf("%v", this.ImageDir) + `,`,
		`Memory:` + fmt.Sprintf("%v", this.Memory) + `,`,
		`Processors:` + fmt.Sprintf("%v", this.Processors) + `,`,
		`Virtualization:` + fmt.Sprintf("%v", this.Virtualization) + `,`,
		`ClockUtc:` + fmt.Sprintf("%v", this.ClockUtc) + `,`,
		`PointingDevice:` + fmt.Sprintf("%v", this.PointingDevice) + `,`,
		`Video:` + strings.Replace(this.Video.String(), "Video", "Video", 1) + `,`,
		`Audio:` + strings.Replace(this.Audio.String(), "Audio", "Audio", 1) + `,`,
		`Storage:` + repeatedStringForStorage + `,`,
		`Network:` + repeatedStringForNetwork + `,`,
		`Serial:` + repeatedStringForSerial + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Video) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Video{`,
		`Memory:` + fmt.Sprintf("%v", this.Memory) + `,`,
		`Displays:` + fmt.Sprintf("%v", this.Displays) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Audio) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Audio{`,
		`EnableOutput:` + fmt.Sprintf("%v", this.EnableOutput) + `,`,
		`EnableInput:` + fmt.Sprintf("%v", this.EnableInput) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDevice{`,
		`Controller:` + fmt.Sprintf("%v", this.Controller) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`Dynamic:` + fmt.Sprintf("%v", this.Dynamic) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkDevice{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Virtio:` + fmt.Sprintf("%v", this.Virtio) + `,`,
		`Mac:` + fmt.Sprintf("%v", this.Mac) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SerialDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SerialDevice{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Irq:` + fmt.Sprintf("%v", this.Irq) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ApiServeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiServeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiServeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiHostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiHostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiPort", wireType)
			}
			m.ApiPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiTimeout", wireType)
			}
			m.ApiTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApiUnserveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiUnserveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiUnserveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiHostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiHostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiPort", wireType)
			}
			m.ApiPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiTimeout", wireType)
			}
			m.ApiTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiHostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiHostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiPort", wireType)
			}
			m.ApiPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiTimeout", wireType)
			}
			m.ApiTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachinesFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualMachinesFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualMachines = append(m.VirtualMachines, &VirtualMachine{})
			if err := m.VirtualMachines[len(m.VirtualMachines)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualMachine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualMachine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualMachine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processors", wireType)
			}
			m.Processors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Processors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtualization", wireType)
			}
			m.Virtualization = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Virtualization |= VirtualizationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockUtc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClockUtc = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointingDevice", wireType)
			}
			m.PointingDevice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PointingDevice |= PointingDeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &Video{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Audio == nil {
				m.Audio = &Audio{}
			}
			if err := m.Audio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = append(m.Storage, &StorageDevice{})
			if err := m.Storage[len(m.Storage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &NetworkDevice{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serial = append(m.Serial, &SerialDevice{})
			if err := m.Serial[len(m.Serial)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Video) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Displays", wireType)
			}
			m.Displays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Displays |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Audio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Audio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Audio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableOutput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableOutput = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableInput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableInput = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			m.Controller = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Controller |= StorageControllerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StorageDeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dynamic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dynamic = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NetworkAttachmentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtio", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Virtio = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SerialDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SerialDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SerialDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Irq", wireType)
			}
			m.Irq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Irq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
