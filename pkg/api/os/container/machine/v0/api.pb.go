// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/api/os/container/machine/v0/api.proto

package v0

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VirtualizationType represents the type of virtualization for a
// machine to use.
type VirtualizationType int32

const (
	// No virtualization.
	VirtualizationType_VIRTUALIZATION_NONE VirtualizationType = 0
	// Use paravirtualization.
	VirtualizationType_VIRTUALIZATION_PARA VirtualizationType = 1
	// Use full virtualization.
	VirtualizationType_VIRTUALIZATION_FULL VirtualizationType = 2
)

var VirtualizationType_name = map[int32]string{
	0: "VIRTUALIZATION_NONE",
	1: "VIRTUALIZATION_PARA",
	2: "VIRTUALIZATION_FULL",
}

var VirtualizationType_value = map[string]int32{
	"VIRTUALIZATION_NONE": 0,
	"VIRTUALIZATION_PARA": 1,
	"VIRTUALIZATION_FULL": 2,
}

func (x VirtualizationType) String() string {
	return proto.EnumName(VirtualizationType_name, int32(x))
}

func (VirtualizationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{0}
}

// PointingDeviceType represents a type of pointing device.
type PointingDeviceType int32

const (
	// No pointing device.
	PointingDeviceType_POINTING_NONE PointingDeviceType = 0
	// A mouse device.
	PointingDeviceType_POINTING_MOUSE PointingDeviceType = 1
	// A touch device.
	PointingDeviceType_POINTING_TOUCH PointingDeviceType = 2
)

var PointingDeviceType_name = map[int32]string{
	0: "POINTING_NONE",
	1: "POINTING_MOUSE",
	2: "POINTING_TOUCH",
}

var PointingDeviceType_value = map[string]int32{
	"POINTING_NONE":  0,
	"POINTING_MOUSE": 1,
	"POINTING_TOUCH": 2,
}

func (x PointingDeviceType) String() string {
	return proto.EnumName(PointingDeviceType_name, int32(x))
}

func (PointingDeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{1}
}

// StorageControllerType represents a type of storage controller.
type StorageControllerType int32

const (
	// Represents a null StorageControllerType.
	StorageControllerType_STORAGE_CONTROLLER_NONE StorageControllerType = 0
	// AHCI/SATA storage controller.
	StorageControllerType_STORAGE_CONTROLLER_SATA StorageControllerType = 1
	// USB storage controller.
	StorageControllerType_STORAGE_CONTROLLER_USB StorageControllerType = 2
)

var StorageControllerType_name = map[int32]string{
	0: "STORAGE_CONTROLLER_NONE",
	1: "STORAGE_CONTROLLER_SATA",
	2: "STORAGE_CONTROLLER_USB",
}

var StorageControllerType_value = map[string]int32{
	"STORAGE_CONTROLLER_NONE": 0,
	"STORAGE_CONTROLLER_SATA": 1,
	"STORAGE_CONTROLLER_USB":  2,
}

func (x StorageControllerType) String() string {
	return proto.EnumName(StorageControllerType_name, int32(x))
}

func (StorageControllerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{2}
}

// StorageDeviceType represents a type of storage device.
type StorageDeviceType int32

const (
	// Represents a null StorageDeviceType.
	StorageDeviceType_STORAGE_DEVICE_NONE StorageDeviceType = 0
	// A solid-state storage device.
	StorageDeviceType_STORAGE_DEVICE_SSD StorageDeviceType = 1
	// A magnetic hard disk device.
	StorageDeviceType_STORAGE_DEVICE_HDD StorageDeviceType = 2
	// An optical disk device.
	StorageDeviceType_STORAGE_DEVICE_OPTICAL StorageDeviceType = 3
)

var StorageDeviceType_name = map[int32]string{
	0: "STORAGE_DEVICE_NONE",
	1: "STORAGE_DEVICE_SSD",
	2: "STORAGE_DEVICE_HDD",
	3: "STORAGE_DEVICE_OPTICAL",
}

var StorageDeviceType_value = map[string]int32{
	"STORAGE_DEVICE_NONE":    0,
	"STORAGE_DEVICE_SSD":     1,
	"STORAGE_DEVICE_HDD":     2,
	"STORAGE_DEVICE_OPTICAL": 3,
}

func (x StorageDeviceType) String() string {
	return proto.EnumName(StorageDeviceType_name, int32(x))
}

func (StorageDeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{3}
}

// NetworkAttachmentType represents a type of attachment for a network adapter.
type NetworkAttachmentType int32

const (
	// The machine is directly attached to the network.
	NetworkAttachmentType_NET_ATTACHMENT_DIRECT NetworkAttachmentType = 0
	// The network is bridged to a VM host network.
	NetworkAttachmentType_NET_ATTACHMENT_BRIDGED NetworkAttachmentType = 1
	// The network is internal to the machine but allows outbound connections to a
	// VM host network using network address translation.
	NetworkAttachmentType_NET_ATTACHMENT_NAT_NETWORK NetworkAttachmentType = 2
)

var NetworkAttachmentType_name = map[int32]string{
	0: "NET_ATTACHMENT_DIRECT",
	1: "NET_ATTACHMENT_BRIDGED",
	2: "NET_ATTACHMENT_NAT_NETWORK",
}

var NetworkAttachmentType_value = map[string]int32{
	"NET_ATTACHMENT_DIRECT":      0,
	"NET_ATTACHMENT_BRIDGED":     1,
	"NET_ATTACHMENT_NAT_NETWORK": 2,
}

func (x NetworkAttachmentType) String() string {
	return proto.EnumName(NetworkAttachmentType_name, int32(x))
}

func (NetworkAttachmentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{4}
}

// ContainerMachine defines settings for a machine hosting OS containers.
type ContainerMachine struct {
	// Total memory of the machine in bytes.
	Memory uint64 `protobuf:"varint,1,opt,name=memory,proto3" json:"memory,omitempty"`
	// Number of processors available.
	Processors uint64 `protobuf:"varint,2,opt,name=processors,proto3" json:"processors,omitempty"`
	// The type of virtualization to use.
	Virtualization VirtualizationType `protobuf:"varint,3,opt,name=virtualization,proto3,enum=os.container.machine.VirtualizationType" json:"virtualization,omitempty"`
	// Whether the hardware clock is UTC time.
	ClockUtc bool `protobuf:"varint,4,opt,name=clock_utc,json=clockUtc,proto3" json:"clock_utc,omitempty"`
	// Primary pointing device type.
	PointingDevice PointingDeviceType `protobuf:"varint,5,opt,name=pointing_device,json=pointingDevice,proto3,enum=os.container.machine.PointingDeviceType" json:"pointing_device,omitempty"`
	// Video settings for the machine.
	Video *Video `protobuf:"bytes,6,opt,name=video,proto3" json:"video,omitempty"`
	// Audio settings for the machine.
	Audio *Audio `protobuf:"bytes,7,opt,name=audio,proto3" json:"audio,omitempty"`
	// Storage devices attached to the machine.
	Storage []*StorageDevice `protobuf:"bytes,8,rep,name=storage,proto3" json:"storage,omitempty"`
	// Network devices attached to the machine.
	Network []*NetworkDevice `protobuf:"bytes,9,rep,name=network,proto3" json:"network,omitempty"`
	// Serial devices attached to the machine.
	Serial               []*SerialDevice `protobuf:"bytes,10,rep,name=serial,proto3" json:"serial,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ContainerMachine) Reset()      { *m = ContainerMachine{} }
func (*ContainerMachine) ProtoMessage() {}
func (*ContainerMachine) Descriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{0}
}
func (m *ContainerMachine) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerMachine) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerMachine.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerMachine) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerMachine.Merge(m, src)
}
func (m *ContainerMachine) XXX_Size() int {
	return m.Size()
}
func (m *ContainerMachine) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerMachine.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerMachine proto.InternalMessageInfo

func (m *ContainerMachine) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *ContainerMachine) GetProcessors() uint64 {
	if m != nil {
		return m.Processors
	}
	return 0
}

func (m *ContainerMachine) GetVirtualization() VirtualizationType {
	if m != nil {
		return m.Virtualization
	}
	return VirtualizationType_VIRTUALIZATION_NONE
}

func (m *ContainerMachine) GetClockUtc() bool {
	if m != nil {
		return m.ClockUtc
	}
	return false
}

func (m *ContainerMachine) GetPointingDevice() PointingDeviceType {
	if m != nil {
		return m.PointingDevice
	}
	return PointingDeviceType_POINTING_NONE
}

func (m *ContainerMachine) GetVideo() *Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *ContainerMachine) GetAudio() *Audio {
	if m != nil {
		return m.Audio
	}
	return nil
}

func (m *ContainerMachine) GetStorage() []*StorageDevice {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *ContainerMachine) GetNetwork() []*NetworkDevice {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *ContainerMachine) GetSerial() []*SerialDevice {
	if m != nil {
		return m.Serial
	}
	return nil
}

// Video defines machine video settings.
type Video struct {
	// Total video memory in bytes.
	Memory uint64 `protobuf:"varint,1,opt,name=memory,proto3" json:"memory,omitempty"`
	// Number of displays attached to the machine.
	Displays             uint64   `protobuf:"varint,2,opt,name=displays,proto3" json:"displays,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Video) Reset()      { *m = Video{} }
func (*Video) ProtoMessage() {}
func (*Video) Descriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{1}
}
func (m *Video) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Video) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Video.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Video) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Video.Merge(m, src)
}
func (m *Video) XXX_Size() int {
	return m.Size()
}
func (m *Video) XXX_DiscardUnknown() {
	xxx_messageInfo_Video.DiscardUnknown(m)
}

var xxx_messageInfo_Video proto.InternalMessageInfo

func (m *Video) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Video) GetDisplays() uint64 {
	if m != nil {
		return m.Displays
	}
	return 0
}

// Audio defines machine audio settings.
type Audio struct {
	// Whether audio output is enabled.
	EnableOutput bool `protobuf:"varint,1,opt,name=enable_output,json=enableOutput,proto3" json:"enable_output,omitempty"`
	// Whether audio input is enabled.
	EnableInput          bool     `protobuf:"varint,2,opt,name=enable_input,json=enableInput,proto3" json:"enable_input,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Audio) Reset()      { *m = Audio{} }
func (*Audio) ProtoMessage() {}
func (*Audio) Descriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{2}
}
func (m *Audio) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Audio) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Audio.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Audio) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Audio.Merge(m, src)
}
func (m *Audio) XXX_Size() int {
	return m.Size()
}
func (m *Audio) XXX_DiscardUnknown() {
	xxx_messageInfo_Audio.DiscardUnknown(m)
}

var xxx_messageInfo_Audio proto.InternalMessageInfo

func (m *Audio) GetEnableOutput() bool {
	if m != nil {
		return m.EnableOutput
	}
	return false
}

func (m *Audio) GetEnableInput() bool {
	if m != nil {
		return m.EnableInput
	}
	return false
}

// StorageDevice defines a storage device attached to the machine.
type StorageDevice struct {
	// The type of storage controller.
	Controller StorageControllerType `protobuf:"varint,1,opt,name=controller,proto3,enum=os.container.machine.StorageControllerType" json:"controller,omitempty"`
	// The type of device.
	Type StorageDeviceType `protobuf:"varint,2,opt,name=type,proto3,enum=os.container.machine.StorageDeviceType" json:"type,omitempty"`
	// Size of the storage in bytes.
	Size_ uint64 `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	// Whether this storage device is dynamically resizable.
	Dynamic              bool     `protobuf:"varint,4,opt,name=dynamic,proto3" json:"dynamic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageDevice) Reset()      { *m = StorageDevice{} }
func (*StorageDevice) ProtoMessage() {}
func (*StorageDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{3}
}
func (m *StorageDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDevice.Merge(m, src)
}
func (m *StorageDevice) XXX_Size() int {
	return m.Size()
}
func (m *StorageDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDevice.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDevice proto.InternalMessageInfo

func (m *StorageDevice) GetController() StorageControllerType {
	if m != nil {
		return m.Controller
	}
	return StorageControllerType_STORAGE_CONTROLLER_NONE
}

func (m *StorageDevice) GetType() StorageDeviceType {
	if m != nil {
		return m.Type
	}
	return StorageDeviceType_STORAGE_DEVICE_NONE
}

func (m *StorageDevice) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *StorageDevice) GetDynamic() bool {
	if m != nil {
		return m.Dynamic
	}
	return false
}

// NetworkDevice defines a network device attached to the machine.
type NetworkDevice struct {
	// The attachment type for the network.
	Type NetworkAttachmentType `protobuf:"varint,1,opt,name=type,proto3,enum=os.container.machine.NetworkAttachmentType" json:"type,omitempty"`
	// Whether to use virtio for virtualization. If false, this
	// represents a real network device or a PCNET device under VM.
	Virtio bool `protobuf:"varint,2,opt,name=virtio,proto3" json:"virtio,omitempty"`
	// The mac address of the device.
	Mac                  string   `protobuf:"bytes,3,opt,name=mac,proto3" json:"mac,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkDevice) Reset()      { *m = NetworkDevice{} }
func (*NetworkDevice) ProtoMessage() {}
func (*NetworkDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{4}
}
func (m *NetworkDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkDevice.Merge(m, src)
}
func (m *NetworkDevice) XXX_Size() int {
	return m.Size()
}
func (m *NetworkDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkDevice.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkDevice proto.InternalMessageInfo

func (m *NetworkDevice) GetType() NetworkAttachmentType {
	if m != nil {
		return m.Type
	}
	return NetworkAttachmentType_NET_ATTACHMENT_DIRECT
}

func (m *NetworkDevice) GetVirtio() bool {
	if m != nil {
		return m.Virtio
	}
	return false
}

func (m *NetworkDevice) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

// SerialDevice defines a 16550A-compatible UART serial device attached to the machine.
type SerialDevice struct {
	// The serial I/O port.
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// The interrupt number to use.
	Irq                  uint32   `protobuf:"varint,2,opt,name=irq,proto3" json:"irq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SerialDevice) Reset()      { *m = SerialDevice{} }
func (*SerialDevice) ProtoMessage() {}
func (*SerialDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_bffaccb55897c02e, []int{5}
}
func (m *SerialDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SerialDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SerialDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SerialDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SerialDevice.Merge(m, src)
}
func (m *SerialDevice) XXX_Size() int {
	return m.Size()
}
func (m *SerialDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_SerialDevice.DiscardUnknown(m)
}

var xxx_messageInfo_SerialDevice proto.InternalMessageInfo

func (m *SerialDevice) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SerialDevice) GetIrq() uint32 {
	if m != nil {
		return m.Irq
	}
	return 0
}

func init() {
	proto.RegisterEnum("os.container.machine.VirtualizationType", VirtualizationType_name, VirtualizationType_value)
	proto.RegisterEnum("os.container.machine.PointingDeviceType", PointingDeviceType_name, PointingDeviceType_value)
	proto.RegisterEnum("os.container.machine.StorageControllerType", StorageControllerType_name, StorageControllerType_value)
	proto.RegisterEnum("os.container.machine.StorageDeviceType", StorageDeviceType_name, StorageDeviceType_value)
	proto.RegisterEnum("os.container.machine.NetworkAttachmentType", NetworkAttachmentType_name, NetworkAttachmentType_value)
	proto.RegisterType((*ContainerMachine)(nil), "os.container.machine.ContainerMachine")
	proto.RegisterType((*Video)(nil), "os.container.machine.Video")
	proto.RegisterType((*Audio)(nil), "os.container.machine.Audio")
	proto.RegisterType((*StorageDevice)(nil), "os.container.machine.StorageDevice")
	proto.RegisterType((*NetworkDevice)(nil), "os.container.machine.NetworkDevice")
	proto.RegisterType((*SerialDevice)(nil), "os.container.machine.SerialDevice")
}

func init() {
	proto.RegisterFile("pkg/api/os/container/machine/v0/api.proto", fileDescriptor_bffaccb55897c02e)
}

var fileDescriptor_bffaccb55897c02e = []byte{
	// 841 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xaf, 0xd3, 0x34, 0x4d, 0x5f, 0x37, 0xc1, 0x3b, 0x6c, 0xbb, 0x26, 0x95, 0xac, 0x90, 0x3d,
	0x10, 0x82, 0x48, 0x20, 0x70, 0x62, 0x85, 0x90, 0x9b, 0x98, 0xd6, 0xda, 0xd4, 0x0e, 0x13, 0xa7,
	0x48, 0x7b, 0xb1, 0x5c, 0x67, 0xc8, 0x8e, 0x9a, 0x78, 0x8c, 0xed, 0x14, 0xd2, 0x13, 0x1f, 0x87,
	0x03, 0xdf, 0x03, 0x8e, 0x1c, 0x39, 0xd2, 0x7c, 0x02, 0x8e, 0x1c, 0xd1, 0x8c, 0xed, 0x2a, 0x69,
	0xdd, 0x88, 0xdb, 0xbc, 0xdf, 0x9f, 0xf7, 0xde, 0xcc, 0xbc, 0xd1, 0xc0, 0xc7, 0xc1, 0xf5, 0xb4,
	0xe3, 0x06, 0xb4, 0xc3, 0xa2, 0x8e, 0xc7, 0xfc, 0xd8, 0xa5, 0x3e, 0x09, 0x3b, 0x73, 0xd7, 0x7b,
	0x47, 0x7d, 0xd2, 0xb9, 0xf9, 0x8c, 0x73, 0xed, 0x20, 0x64, 0x31, 0x43, 0x2f, 0x58, 0xd4, 0xbe,
	0x97, 0xb4, 0x53, 0x49, 0xed, 0xc5, 0x94, 0x4d, 0x99, 0x10, 0x74, 0xf8, 0x2a, 0xd1, 0xd6, 0x4e,
	0xa6, 0x8c, 0x4d, 0x67, 0xa4, 0x23, 0xa2, 0xab, 0xc5, 0x0f, 0x1d, 0x32, 0x0f, 0xe2, 0x65, 0x42,
	0x36, 0x7e, 0x2b, 0x82, 0xdc, 0xcb, 0x12, 0x5d, 0x24, 0x79, 0xd0, 0x31, 0x94, 0xe6, 0x64, 0xce,
	0xc2, 0xa5, 0x22, 0xd5, 0xa5, 0x66, 0x11, 0xa7, 0x11, 0x52, 0x01, 0x82, 0x90, 0x79, 0x24, 0x8a,
	0x58, 0x18, 0x29, 0x05, 0xc1, 0xad, 0x21, 0x68, 0x08, 0xd5, 0x1b, 0x1a, 0xc6, 0x0b, 0x77, 0x46,
	0x6f, 0xdd, 0x98, 0x32, 0x5f, 0xd9, 0xad, 0x4b, 0xcd, 0x6a, 0xb7, 0xd9, 0xce, 0x6b, 0xb7, 0x7d,
	0xb9, 0xa1, 0xb5, 0x97, 0x01, 0xc1, 0x0f, 0xfc, 0xe8, 0x04, 0x0e, 0xbc, 0x19, 0xf3, 0xae, 0x9d,
	0x45, 0xec, 0x29, 0xc5, 0xba, 0xd4, 0x2c, 0xe3, 0xb2, 0x00, 0xc6, 0xb1, 0x87, 0xbe, 0x83, 0xf7,
	0x02, 0x46, 0xfd, 0x98, 0xfa, 0x53, 0x67, 0x42, 0x6e, 0xa8, 0x47, 0x94, 0xbd, 0x6d, 0xf5, 0x86,
	0xa9, 0xb8, 0x2f, 0xb4, 0x49, 0xbd, 0x60, 0x03, 0x43, 0x9f, 0xc3, 0xde, 0x0d, 0x9d, 0x10, 0xa6,
	0x94, 0xea, 0x52, 0xf3, 0xb0, 0x7b, 0xf2, 0x54, 0xe3, 0x13, 0xc2, 0x70, 0xa2, 0xe4, 0x16, 0x77,
	0x31, 0xa1, 0x4c, 0xd9, 0xdf, 0x66, 0xd1, 0xb8, 0x04, 0x27, 0x4a, 0xf4, 0x35, 0xec, 0x47, 0x31,
	0x0b, 0xdd, 0x29, 0x51, 0xca, 0xf5, 0xdd, 0xe6, 0x61, 0xf7, 0x55, 0xbe, 0x69, 0x94, 0x88, 0x92,
	0xde, 0x70, 0xe6, 0xe1, 0x76, 0x9f, 0xc4, 0x3f, 0xb1, 0xf0, 0x5a, 0x39, 0xd8, 0x66, 0x37, 0x13,
	0x51, 0x66, 0x4f, 0x3d, 0xe8, 0x2b, 0x28, 0x45, 0x24, 0xa4, 0xee, 0x4c, 0x01, 0xe1, 0x6e, 0x3c,
	0x51, 0x5c, 0x68, 0x52, 0x73, 0xea, 0x68, 0xbc, 0x86, 0x3d, 0xb1, 0xf9, 0x27, 0x47, 0xa4, 0x06,
	0xe5, 0x09, 0x8d, 0x82, 0x99, 0xbb, 0xcc, 0x06, 0xe4, 0x3e, 0x6e, 0x58, 0xb0, 0x27, 0x8e, 0x01,
	0xbd, 0x82, 0x0a, 0xf1, 0xdd, 0xab, 0x19, 0x71, 0xd8, 0x22, 0x0e, 0x16, 0xb1, 0xc8, 0x51, 0xc6,
	0xcf, 0x12, 0xd0, 0x12, 0x18, 0xfa, 0x10, 0xd2, 0xd8, 0xa1, 0x3e, 0xd7, 0x14, 0x84, 0xe6, 0x30,
	0xc1, 0x0c, 0x0e, 0x35, 0x7e, 0x97, 0xa0, 0xb2, 0x71, 0x46, 0xe8, 0x0d, 0x00, 0xdf, 0x49, 0xc8,
	0x66, 0x33, 0x12, 0x8a, 0xb4, 0xd5, 0xee, 0x27, 0x5b, 0x0f, 0xb7, 0x77, 0x2f, 0x17, 0x03, 0xb1,
	0x66, 0x47, 0xaf, 0xa1, 0x18, 0x2f, 0x03, 0x22, 0x2a, 0x57, 0xbb, 0x1f, 0xfd, 0x8f, 0x3b, 0x12,
	0x29, 0x84, 0x09, 0x21, 0x28, 0x46, 0xf4, 0x96, 0x88, 0x17, 0x50, 0xc4, 0x62, 0x8d, 0x14, 0xd8,
	0x9f, 0x2c, 0x7d, 0x77, 0x4e, 0xb3, 0x59, 0xce, 0xc2, 0xc6, 0x2d, 0x54, 0x36, 0x6e, 0x0b, 0x7d,
	0x93, 0xd6, 0xde, 0xba, 0x85, 0xd4, 0xa2, 0xc5, 0xb1, 0xeb, 0xbd, 0x9b, 0x13, 0x3f, 0x5e, 0xab,
	0x7f, 0x0c, 0x25, 0xfe, 0x96, 0x28, 0x4b, 0x0f, 0x2e, 0x8d, 0x90, 0x0c, 0xbb, 0x73, 0xd7, 0x13,
	0x6d, 0x1d, 0x60, 0xbe, 0x6c, 0x7c, 0x09, 0xcf, 0xd6, 0xef, 0x9a, 0x77, 0x1e, 0xb0, 0x30, 0xb9,
	0x94, 0x0a, 0x16, 0x6b, 0xee, 0xa2, 0xe1, 0x8f, 0x22, 0x55, 0x05, 0xf3, 0x65, 0xcb, 0x01, 0xf4,
	0xf8, 0xfd, 0xa2, 0x97, 0xf0, 0xfe, 0xa5, 0x81, 0xed, 0xb1, 0x36, 0x30, 0xde, 0x6a, 0xb6, 0x61,
	0x99, 0x8e, 0x69, 0x99, 0xba, 0xbc, 0x93, 0x43, 0x0c, 0x35, 0xac, 0xc9, 0x52, 0x0e, 0xf1, 0xed,
	0x78, 0x30, 0x90, 0x0b, 0x2d, 0x0b, 0xd0, 0xe3, 0x07, 0x8b, 0x9e, 0x43, 0x65, 0x68, 0x19, 0xa6,
	0x6d, 0x98, 0x67, 0x59, 0x6a, 0x04, 0xd5, 0x7b, 0xe8, 0xc2, 0x1a, 0x8f, 0x74, 0x59, 0xda, 0xc0,
	0x6c, 0x6b, 0xdc, 0x3b, 0x97, 0x0b, 0xad, 0x39, 0x1c, 0xe5, 0xde, 0x39, 0x3a, 0x81, 0x97, 0x23,
	0xdb, 0xc2, 0xda, 0x99, 0xee, 0xf4, 0x2c, 0xd3, 0xc6, 0xd6, 0x60, 0xa0, 0xe3, 0x2c, 0x7b, 0x3e,
	0x39, 0xd2, 0x6c, 0xde, 0x7c, 0x0d, 0x8e, 0x73, 0xc8, 0xf1, 0xe8, 0x54, 0x2e, 0xb4, 0x7e, 0x86,
	0xe7, 0x8f, 0x66, 0x83, 0xef, 0x36, 0x33, 0xf4, 0xf5, 0x4b, 0xa3, 0xa7, 0x67, 0x65, 0x8e, 0x01,
	0x3d, 0x20, 0x46, 0xa3, 0xbe, 0x2c, 0xe5, 0xe0, 0xe7, 0xfd, 0xbe, 0x5c, 0x58, 0xaf, 0x9c, 0xe2,
	0xd6, 0xd0, 0x36, 0x7a, 0xda, 0x40, 0xde, 0x6d, 0xf9, 0x70, 0x94, 0x3b, 0x19, 0xe8, 0x03, 0x38,
	0x32, 0x75, 0xdb, 0xd1, 0x6c, 0x5b, 0xeb, 0x9d, 0x5f, 0xe8, 0xa6, 0xed, 0xf4, 0x0d, 0xac, 0xf7,
	0x6c, 0x79, 0x87, 0xe7, 0x7b, 0x40, 0x9d, 0x62, 0xa3, 0x7f, 0xa6, 0xf3, 0x1e, 0x54, 0xa8, 0x3d,
	0xe0, 0x4c, 0xcd, 0x76, 0x4c, 0xdd, 0xfe, 0xde, 0xc2, 0x6f, 0xe4, 0xc2, 0x69, 0xff, 0xaf, 0x3b,
	0x75, 0xe7, 0x9f, 0x3b, 0x55, 0xfa, 0xf7, 0x4e, 0xdd, 0xf9, 0x65, 0xa5, 0x4a, 0xbf, 0xae, 0x54,
	0xe9, 0x8f, 0x95, 0x2a, 0xfd, 0xb9, 0x52, 0xa5, 0xbf, 0x57, 0xaa, 0xf4, 0xb6, 0xe1, 0xce, 0xe2,
	0x4f, 0x59, 0xb4, 0xed, 0x73, 0xbb, 0x2a, 0x89, 0x0f, 0xe9, 0x8b, 0xff, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x9f, 0x2e, 0x01, 0xcf, 0x06, 0x07, 0x00, 0x00,
}

func (this *ContainerMachine) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerMachine)
	if !ok {
		that2, ok := that.(ContainerMachine)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Memory != that1.Memory {
		return false
	}
	if this.Processors != that1.Processors {
		return false
	}
	if this.Virtualization != that1.Virtualization {
		return false
	}
	if this.ClockUtc != that1.ClockUtc {
		return false
	}
	if this.PointingDevice != that1.PointingDevice {
		return false
	}
	if !this.Video.Equal(that1.Video) {
		return false
	}
	if !this.Audio.Equal(that1.Audio) {
		return false
	}
	if len(this.Storage) != len(that1.Storage) {
		return false
	}
	for i := range this.Storage {
		if !this.Storage[i].Equal(that1.Storage[i]) {
			return false
		}
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if len(this.Serial) != len(that1.Serial) {
		return false
	}
	for i := range this.Serial {
		if !this.Serial[i].Equal(that1.Serial[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Video) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Video)
	if !ok {
		that2, ok := that.(Video)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Memory != that1.Memory {
		return false
	}
	if this.Displays != that1.Displays {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Audio) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Audio)
	if !ok {
		that2, ok := that.(Audio)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EnableOutput != that1.EnableOutput {
		return false
	}
	if this.EnableInput != that1.EnableInput {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *StorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDevice)
	if !ok {
		that2, ok := that.(StorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Controller != that1.Controller {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.Dynamic != that1.Dynamic {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *NetworkDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkDevice)
	if !ok {
		that2, ok := that.(NetworkDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Virtio != that1.Virtio {
		return false
	}
	if this.Mac != that1.Mac {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SerialDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SerialDevice)
	if !ok {
		that2, ok := that.(SerialDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Irq != that1.Irq {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ContainerMachine) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&v0.ContainerMachine{")
	s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	s = append(s, "Processors: "+fmt.Sprintf("%#v", this.Processors)+",\n")
	s = append(s, "Virtualization: "+fmt.Sprintf("%#v", this.Virtualization)+",\n")
	s = append(s, "ClockUtc: "+fmt.Sprintf("%#v", this.ClockUtc)+",\n")
	s = append(s, "PointingDevice: "+fmt.Sprintf("%#v", this.PointingDevice)+",\n")
	if this.Video != nil {
		s = append(s, "Video: "+fmt.Sprintf("%#v", this.Video)+",\n")
	}
	if this.Audio != nil {
		s = append(s, "Audio: "+fmt.Sprintf("%#v", this.Audio)+",\n")
	}
	if this.Storage != nil {
		s = append(s, "Storage: "+fmt.Sprintf("%#v", this.Storage)+",\n")
	}
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.Serial != nil {
		s = append(s, "Serial: "+fmt.Sprintf("%#v", this.Serial)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Video) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v0.Video{")
	s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	s = append(s, "Displays: "+fmt.Sprintf("%#v", this.Displays)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Audio) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v0.Audio{")
	s = append(s, "EnableOutput: "+fmt.Sprintf("%#v", this.EnableOutput)+",\n")
	s = append(s, "EnableInput: "+fmt.Sprintf("%#v", this.EnableInput)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v0.StorageDevice{")
	s = append(s, "Controller: "+fmt.Sprintf("%#v", this.Controller)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "Dynamic: "+fmt.Sprintf("%#v", this.Dynamic)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v0.NetworkDevice{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Virtio: "+fmt.Sprintf("%#v", this.Virtio)+",\n")
	s = append(s, "Mac: "+fmt.Sprintf("%#v", this.Mac)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SerialDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v0.SerialDevice{")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Irq: "+fmt.Sprintf("%#v", this.Irq)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ContainerMachine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerMachine) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerMachine) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Serial) > 0 {
		for iNdEx := len(m.Serial) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Serial[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Storage) > 0 {
		for iNdEx := len(m.Storage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Storage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Audio != nil {
		{
			size, err := m.Audio.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.PointingDevice != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PointingDevice))
		i--
		dAtA[i] = 0x28
	}
	if m.ClockUtc {
		i--
		if m.ClockUtc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Virtualization != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Virtualization))
		i--
		dAtA[i] = 0x18
	}
	if m.Processors != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Processors))
		i--
		dAtA[i] = 0x10
	}
	if m.Memory != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Video) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Video) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Video) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Displays != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Displays))
		i--
		dAtA[i] = 0x10
	}
	if m.Memory != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Audio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Audio) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Audio) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnableInput {
		i--
		if m.EnableInput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.EnableOutput {
		i--
		if m.EnableOutput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StorageDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dynamic {
		i--
		if m.Dynamic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Size_ != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Controller != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Controller))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Virtio {
		i--
		if m.Virtio {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SerialDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SerialDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SerialDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Irq != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Irq))
		i--
		dAtA[i] = 0x10
	}
	if m.Port != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ContainerMachine) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Memory != 0 {
		n += 1 + sovApi(uint64(m.Memory))
	}
	if m.Processors != 0 {
		n += 1 + sovApi(uint64(m.Processors))
	}
	if m.Virtualization != 0 {
		n += 1 + sovApi(uint64(m.Virtualization))
	}
	if m.ClockUtc {
		n += 2
	}
	if m.PointingDevice != 0 {
		n += 1 + sovApi(uint64(m.PointingDevice))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Audio != nil {
		l = m.Audio.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Storage) > 0 {
		for _, e := range m.Storage {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Serial) > 0 {
		for _, e := range m.Serial {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Video) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Memory != 0 {
		n += 1 + sovApi(uint64(m.Memory))
	}
	if m.Displays != 0 {
		n += 1 + sovApi(uint64(m.Displays))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Audio) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableOutput {
		n += 2
	}
	if m.EnableInput {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Controller != 0 {
		n += 1 + sovApi(uint64(m.Controller))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	if m.Dynamic {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Virtio {
		n += 2
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SerialDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovApi(uint64(m.Port))
	}
	if m.Irq != 0 {
		n += 1 + sovApi(uint64(m.Irq))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ContainerMachine) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStorage := "[]*StorageDevice{"
	for _, f := range this.Storage {
		repeatedStringForStorage += strings.Replace(f.String(), "StorageDevice", "StorageDevice", 1) + ","
	}
	repeatedStringForStorage += "}"
	repeatedStringForNetwork := "[]*NetworkDevice{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(f.String(), "NetworkDevice", "NetworkDevice", 1) + ","
	}
	repeatedStringForNetwork += "}"
	repeatedStringForSerial := "[]*SerialDevice{"
	for _, f := range this.Serial {
		repeatedStringForSerial += strings.Replace(f.String(), "SerialDevice", "SerialDevice", 1) + ","
	}
	repeatedStringForSerial += "}"
	s := strings.Join([]string{`&ContainerMachine{`,
		`Memory:` + fmt.Sprintf("%v", this.Memory) + `,`,
		`Processors:` + fmt.Sprintf("%v", this.Processors) + `,`,
		`Virtualization:` + fmt.Sprintf("%v", this.Virtualization) + `,`,
		`ClockUtc:` + fmt.Sprintf("%v", this.ClockUtc) + `,`,
		`PointingDevice:` + fmt.Sprintf("%v", this.PointingDevice) + `,`,
		`Video:` + strings.Replace(this.Video.String(), "Video", "Video", 1) + `,`,
		`Audio:` + strings.Replace(this.Audio.String(), "Audio", "Audio", 1) + `,`,
		`Storage:` + repeatedStringForStorage + `,`,
		`Network:` + repeatedStringForNetwork + `,`,
		`Serial:` + repeatedStringForSerial + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Video) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Video{`,
		`Memory:` + fmt.Sprintf("%v", this.Memory) + `,`,
		`Displays:` + fmt.Sprintf("%v", this.Displays) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Audio) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Audio{`,
		`EnableOutput:` + fmt.Sprintf("%v", this.EnableOutput) + `,`,
		`EnableInput:` + fmt.Sprintf("%v", this.EnableInput) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDevice{`,
		`Controller:` + fmt.Sprintf("%v", this.Controller) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`Dynamic:` + fmt.Sprintf("%v", this.Dynamic) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkDevice{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Virtio:` + fmt.Sprintf("%v", this.Virtio) + `,`,
		`Mac:` + fmt.Sprintf("%v", this.Mac) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SerialDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SerialDevice{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Irq:` + fmt.Sprintf("%v", this.Irq) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ContainerMachine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerMachine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerMachine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processors", wireType)
			}
			m.Processors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Processors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtualization", wireType)
			}
			m.Virtualization = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Virtualization |= VirtualizationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockUtc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClockUtc = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointingDevice", wireType)
			}
			m.PointingDevice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PointingDevice |= PointingDeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &Video{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Audio == nil {
				m.Audio = &Audio{}
			}
			if err := m.Audio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = append(m.Storage, &StorageDevice{})
			if err := m.Storage[len(m.Storage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &NetworkDevice{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serial = append(m.Serial, &SerialDevice{})
			if err := m.Serial[len(m.Serial)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Video) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Displays", wireType)
			}
			m.Displays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Displays |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Audio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Audio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Audio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableOutput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableOutput = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableInput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableInput = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			m.Controller = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Controller |= StorageControllerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StorageDeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dynamic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dynamic = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NetworkAttachmentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtio", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Virtio = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SerialDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SerialDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SerialDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Irq", wireType)
			}
			m.Irq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Irq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
