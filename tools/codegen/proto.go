package main

import (
	"alt-os/exe"
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"strings"
	"sync"

	_ "github.com/gogo/googleapis/google/api"
	"github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	_ "google.golang.org/grpc"
)

// Maximum number of protobuf packages to be able to process.
const _MAX_PROTO_PACKAGES = 1000

// Autogenerated code template for imports.
const _PROTO_IMPORT_AUTOGEN = `// Code generated by codegen. DO NOT EDIT.
package api
import (
	"errors"
	"fmt"
	"github.com/gogo/protobuf/proto"
`

// Autogenerated code template: zmarshaling.go.
const _PROTO_MARSHAL_AUTOGEN_0 = `)
// unmarshalKind unmarshals the specified bytes to the specified message kind.
func unmarshalKind(kind, version string, value []byte) (proto.Message, error) {
	doUnmarshal := func(msg proto.Message) (proto.Message, error) {
		if err := proto.Unmarshal(value, msg); err != nil {
			return nil, err
		}
		return msg, nil
	}
	kindVersion := kind + "/" + version
	switch kindVersion {
	default:
		return nil, errors.New("unrecognized message kind/version: " + kindVersion)
`

// Autogenerated code template: zmarshaling.go.
const _PROTO_MARSHAL_AUTOGEN_1 = `	}
}
// marshalKind marshals the specified message to a slice of bytes with the kind and version.
func marshalKind(msg proto.Message) (kind, version string, bytes []byte, err error) {
	doMarshal := func(kind, version string, msg proto.Message) (string, string, []byte, error) {
		if bytes, err := proto.Marshal(msg); err != nil {
			return "", "", nil, err
		} else {
			return kind, version, bytes, nil
		}
	}
	switch msg.(type) {
	default:
		return "", "", nil, errors.New("unrecognized message type")
`

// Autogenerated code template: zmarshaling.go.
const _PROTO_MARSHAL_AUTOGEN_2 = `	}
}
`

// Autogenerated code template: zservicing.go.
const _PROTO_SERVICE_AUTOGEN_0 = `)
// serviceMessageKinds processes each specific message kind.
func serviceMessageKinds(ctxt *ApiServiceContext) error {
	for _, apiMsg := range ctxt.MessageQueue {
		switch msg := apiMsg.Def.(type) {
		default:
			return errors.New("invalid message kind: " + apiMsg.Kind)
`

// Autogenerated code template: zservicing.go.
const _PROTO_SERVICE_AUTOGEN_1 = `}
}
for addr := range ctxt.AddrServerMap {
	if err := ctxt.AddrStopWaitMap[addr](); err != nil {
		return nil
	}
}
ctxt.ServerWg.Wait()
return nil
}
// makeClientKind makes a new specific grpc client kind in the context.
func makeClientKind(addr string, ctxt *ApiServiceContext) error {
switch ctxt.AddrKindVerMap[addr] {
default:
	return errors.New("invalid client kindVer: " + ctxt.AddrKindVerMap[addr])
`

// Autogenerated code template: zservicing.go.
const _PROTO_SERVICE_AUTOGEN_2 = `}
if ctxt.AddrClientMap[addr] == nil {
	return errors.New("failed to make client " + ctxt.AddrKindVerMap[addr] + " for " + addr)
}
return nil
}
// makeServerKind makes a new specific grpc server kind in the context.
func makeServerKind(addr string, ctxt *ApiServiceContext) error {
switch ctxt.AddrKindVerMap[addr] {
default:
	return errors.New("invalid impl kindVer: " + ctxt.AddrKindVerMap[addr])
`

// Autogenerated code template: zservicing.go.
const _PROTO_SERVICE_AUTOGEN_3 = `}
return nil
}
// Specific kinds follow grpc request calls follow. Functions called by serviceMessageKinds.
`

// Autogenerated code template: zservicing.go.
func protoServiceAutogenReqFunc(kind, version, method, serviceName, goImportName string) string {
	format := `
	func req_%s_%s_%s(req *%s.%sRequest, ctxt *ApiServiceContext) error {
		if addr, grpcContext, grpcCancel, err := makeClientGrpcContextForMsg("%s", "%s", req, ctxt); err != nil {
			return err
		} else {
			defer grpcCancel()
			client, ok := ctxt.AddrClientMap[addr].(%s.%sClient)
			if !ok {
				return errors.New("no client for "+addr)
			}
			if resp, err := client.%s(grpcContext, req); err != nil {
				return err
			} else if handler := ctxt.RespHandlerMap["%s/%s.%s"]; handler == nil {
				return nil
			} else if err := handler(resp); err != nil {
				return err
			}
		}
		return nil
	}
	`
	return fmt.Sprintf(format, serviceName, version, method, goImportName, method,
		kind, version, goImportName, serviceName, method, kind, version, method)
}

// Autogenerated code template: zservicing.go.
func protoServiceAutogenReqMsgKindCase(kind, version, method, serviceName, goImportName string) string {
	str := fmt.Sprintf("case *%s.%sRequest:\n", goImportName, method)
	if method == "ApiServe" {
		// Start a new grpc server in the context before initial request.
		format := `if err := newServer("%s", "%s", msg, ctxt); err != nil {
			return err
		} else `
		str += fmt.Sprintf(format, kind, version)
	}
	format := `if err := req_%s_%s_%s(msg, ctxt); err != nil {
		return err
	}`
	str += fmt.Sprintf(format, serviceName, version, method)
	if method == "ApiUnserve" {
		// Stop the grpc server and remove it from the context after the unserve request.
		str += ` else if err := stopServer(fmt.Sprintf("%s:%d", msg.GetHostname(), msg.GetPort()), ctxt); err != nil {
			return err
		}`
	}
	str += "\n"
	return str
}

// Stores information about the api for a single package.
type protoPackageApiInfo struct {
	PackageName  string
	Version      string
	GoImportName string
	GoImportPath string
	TypeNames    []string
	ServiceInfos []*protoServiceInfo
}

// Stores information about a specific service kind.
type protoServiceInfo struct {
	ServiceName string
	MethodNames []string
}

// protogen walks the api source tree and auto-generates all protocol buffer source
// files in the correct locations, overwriting any existing files. Exits with
// error on failure.
func protogen(ctxt *CodegenContext) {
	if stdOut, stdErr, err := exe.Doexec("", "go", "install", "github.com/gogo/protobuf/protoc-gen-gogo"); err != nil {
		exe.Fatal("installing protoc-gen-gogo", exe.ErrOutput(stdOut, stdErr, err), ctxt.ExeContext)
	}
	if stdOut, stdErr, err := exe.Doexec("", "go", "install", "golang.org/x/tools/cmd/goimports"); err != nil {
		exe.Fatal("installing goimports", exe.ErrOutput(stdOut, stdErr, err), ctxt.ExeContext)
	}

	apiProtoDir := filepath.Clean(filepath.Join(ctxt.SrcRootDir, "pkg", "api"))
	gogoprotobufDir := ""
	protobufDir := ""
	if dir, err := exe.FindPackageModDir("github.com/gogo/protobuf"); err != nil {
		exe.Fatal("finding gogoprotobufDir", err, ctxt.ExeContext)
	} else {
		gogoprotobufDir = filepath.Clean(dir)
		protobufDir = filepath.Join(dir, "protobuf") // Standard Google includes.
	}

	descOutDir := filepath.Clean(filepath.Join(ctxt.SrcRootDir, "workspace", "desc"))
	if err := os.MkdirAll(descOutDir, 0755); err != nil {
		exe.Fatal("making desc output dir", err, ctxt.ExeContext)
	}

	outStr := "--gogo_out=plugins=grpc,paths=source_relative,"
	outStr += "Mgoogle/protobuf/any.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/api.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/descriptor.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/duration.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/empty.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/field_mask.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/source_context.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/struct.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/timestamp.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/type.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/wrappers.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/api/annotations.proto=github.com/gogo/googleapis/google/api:."
	baseArgs := []string{"-I=.", "-I=" + apiProtoDir, "-I=" + gogoprotobufDir, "-I=" + protobufDir, outStr}

	runProtoc := func(pbFile string, wg *sync.WaitGroup, chPackageApiInfo chan<- *protoPackageApiInfo) {
		wg.Add(1)
		importName, importPath := protoPathToImports(pbFile)
		version := string(importName[strings.LastIndex(importName, "_")+1:])
		descFile := filepath.Clean(filepath.Join(descOutDir, importName+".pb"))
		args := append(baseArgs, "--descriptor_set_out="+descFile)
		args = append(args, pbFile)
		if stdOut, stdErr, err := exe.Doexec("", "protoc", args...); err != nil {
			exe.Fatal("compiling protobuf", exe.ErrOutput(stdOut, stdErr, err), ctxt.ExeContext)
		} else {
			fmt.Println(pbFile)
		}
		desc := &descriptor.FileDescriptorSet{}
		if data, err := os.ReadFile(descFile); err != nil {
			exe.Fatal("reading protobuf desc", err, ctxt.ExeContext)
		} else if err = proto.Unmarshal(data, desc); err != nil {
			exe.Fatal("unmarshaling protobuf desc", err, ctxt.ExeContext)
		}
		var typeNames []string
		var serviceInfos []*protoServiceInfo
		var packageName string
		for _, f := range desc.File {
			packageName = *f.Package
			for _, msgType := range f.MessageType {
				typeNames = append(typeNames, *msgType.Name)
			}
			for _, service := range f.Service {
				serviceInfo := &protoServiceInfo{
					ServiceName: *service.Name,
				}
				for _, method := range service.Method {
					serviceInfo.MethodNames = append(serviceInfo.MethodNames, *method.Name)
				}
				serviceInfos = append(serviceInfos, serviceInfo)
			}
		}
		chPackageApiInfo <- &protoPackageApiInfo{
			PackageName:  packageName,
			Version:      version,
			GoImportName: importName,
			GoImportPath: importPath,
			TypeNames:    typeNames,
			ServiceInfos: serviceInfos,
		}
		wg.Done()
	}

	wg := &sync.WaitGroup{}
	chPackageApiInfo := make(chan *protoPackageApiInfo, _MAX_PROTO_PACKAGES)
	filepath.WalkDir(filepath.Join(ctxt.SrcRootDir, "pkg", "api"), func(pathname string, d fs.DirEntry, err error) error {
		if !d.Type().IsRegular() || !strings.HasSuffix(pathname, ".proto") {
			return nil
		}
		pbFile := strings.Trim(strings.TrimPrefix(pathname, ctxt.SrcRootDir), "/\\")
		pbFile = "./" + strings.ReplaceAll(pbFile, "\\", "/")
		runProtoc(pbFile, wg, chPackageApiInfo)
		return nil
	})
	wg.Wait()
	close(chPackageApiInfo)
	os.RemoveAll(descOutDir)

	// Consume all the info for generated packages and generate the go code for
	// marshaling and grpc servicing.
	var pkgInfos []*protoPackageApiInfo
	for info := range chPackageApiInfo {
		pkgInfos = append(pkgInfos, info)
	}
	protoGenerateMarshaling(pkgInfos, ctxt)
	protoGenerateServicing(pkgInfos, ctxt)
}

// protoPathToImports converts the specified relative .proto path into a Go import name and path.
func protoPathToImports(protoPath string) (string, string) {
	name := path.Dir(strings.TrimPrefix(protoPath, "./pkg/api/"))
	path := "alt-os/api/" + name
	name = "api_" + strings.ReplaceAll(name, "/", "_")
	return name, path
}

// protoGenerateMarshaling writes an autogenerated go file to the api package for
// protobuf message marshaling/unmarshaling.
func protoGenerateMarshaling(pkgInfos []*protoPackageApiInfo, ctxt *CodegenContext) {
	outFilename := filepath.Clean(filepath.Join(ctxt.SrcRootDir, "pkg", "api", "zmarshaling.go"))
	if f, err := os.Create(outFilename); err != nil {
		exe.Fatal("creating "+outFilename, err, ctxt.ExeContext)
	} else {
		f.WriteString(_PROTO_IMPORT_AUTOGEN)
		for _, pkgInfo := range pkgInfos {
			f.WriteString(fmt.Sprintf("\t%s \"%s\"\n", pkgInfo.GoImportName, pkgInfo.GoImportPath))
		}
		f.WriteString(_PROTO_MARSHAL_AUTOGEN_0)
		for _, pkgInfo := range pkgInfos {
			for _, typeName := range pkgInfo.TypeNames {
				format := `case "api.%s.%s/%s":
					return doUnmarshal(&%s.%s{})
				`
				f.WriteString(fmt.Sprintf(format, pkgInfo.PackageName, typeName,
					pkgInfo.Version, pkgInfo.GoImportName, typeName))
			}
		}
		f.WriteString(_PROTO_MARSHAL_AUTOGEN_1)
		for _, pkgInfo := range pkgInfos {
			for _, typeName := range pkgInfo.TypeNames {
				format := `case *%s.%s:
					return doMarshal("api.%s.%s", "%s", msg)
				`
				f.WriteString(fmt.Sprintf(format, pkgInfo.GoImportName, typeName,
					pkgInfo.PackageName, typeName, pkgInfo.Version))
			}
		}
		f.WriteString(_PROTO_MARSHAL_AUTOGEN_2)
		f.Close()
	}

	if stdOut, stdErr, err := exe.Doexec("", "goimports", "-w", outFilename); err != nil {
		exe.Fatal("formatting "+outFilename, exe.ErrOutput(stdOut, stdErr, err), ctxt.ExeContext)
	}
}

// protoGenerateServicing writes an autogenerated go file to the api package for
// grpc servicing.
func protoGenerateServicing(pkgInfos []*protoPackageApiInfo, ctxt *CodegenContext) {
	outFilename := filepath.Clean(filepath.Join(ctxt.SrcRootDir, "pkg", "api", "zservicing.go"))
	if f, err := os.Create(outFilename); err != nil {
		exe.Fatal("creating "+outFilename, err, ctxt.ExeContext)
	} else {
		f.WriteString(_PROTO_IMPORT_AUTOGEN)
		for _, pkgInfo := range pkgInfos {
			f.WriteString(fmt.Sprintf("\t%s \"%s\"\n", pkgInfo.GoImportName, pkgInfo.GoImportPath))
		}
		f.WriteString(_PROTO_SERVICE_AUTOGEN_0)
		for _, pkgInfo := range pkgInfos {
			for _, serviceInfo := range pkgInfo.ServiceInfos {
				kind := fmt.Sprintf("api.%s.%s", pkgInfo.PackageName, serviceInfo.ServiceName)
				for _, method := range serviceInfo.MethodNames {
					caseStr := protoServiceAutogenReqMsgKindCase(kind, pkgInfo.Version, method,
						serviceInfo.ServiceName, pkgInfo.GoImportName)
					f.WriteString(caseStr)
				}
			}
		}
		f.WriteString(_PROTO_SERVICE_AUTOGEN_1)
		for _, pkgInfo := range pkgInfos {
			for _, serviceInfo := range pkgInfo.ServiceInfos {
				format := `case "api.%s.%s/%s":
					ctxt.AddrClientMap[addr] = %s.New%sClient(ctxt.AddrGrpcConnMap[addr])`
				f.WriteString(fmt.Sprintf(format, pkgInfo.PackageName, serviceInfo.ServiceName,
					pkgInfo.Version, pkgInfo.GoImportName, serviceInfo.ServiceName))
			}
		}
		f.WriteString(_PROTO_SERVICE_AUTOGEN_2)
		for _, pkgInfo := range pkgInfos {
			for _, serviceInfo := range pkgInfo.ServiceInfos {
				format := `case "api.%s.%s/%s":
					srv := ctxt.KindImplMap[ctxt.AddrKindVerMap[addr]].(%s.%sServer)
					%s.Register%sServer(ctxt.AddrGrpcServerMap[addr], srv)
					ctxt.AddrServerMap[addr] = srv`
				f.WriteString(fmt.Sprintf(format, pkgInfo.PackageName, serviceInfo.ServiceName,
					pkgInfo.Version, pkgInfo.GoImportName, serviceInfo.ServiceName,
					pkgInfo.GoImportName, serviceInfo.ServiceName))
			}
		}
		f.WriteString(_PROTO_SERVICE_AUTOGEN_3)
		for _, pkgInfo := range pkgInfos {
			for _, serviceInfo := range pkgInfo.ServiceInfos {
				kind := fmt.Sprintf("api.%s.%s", pkgInfo.PackageName, serviceInfo.ServiceName)
				for _, method := range serviceInfo.MethodNames {
					funcStr := protoServiceAutogenReqFunc(kind, pkgInfo.Version, method,
						serviceInfo.ServiceName, pkgInfo.GoImportName)
					f.WriteString(funcStr)
				}
			}
		}
		f.Close()
	}

	if stdOut, stdErr, err := exe.Doexec("", "goimports", "-w", outFilename); err != nil {
		exe.Fatal("formatting "+outFilename, exe.ErrOutput(stdOut, stdErr, err), ctxt.ExeContext)
	}
}
