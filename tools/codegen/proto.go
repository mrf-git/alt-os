package main

import (
	"alt-os/exe"
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"strings"
	"sync"

	_ "github.com/gogo/googleapis/google/api"
	"github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	_ "google.golang.org/grpc"
)

// Maximum number of protobuf packages to be able to process.
const _MAX_PROTO_PACKAGES = 1000

// Autogenerated code template.
const _PROTO_AUTOGEN_0 = `// Code generated by codegen. DO NOT EDIT.
package api
import (
	"errors"
	"github.com/gogo/protobuf/proto"
`

// Autogenerated code template.
const _PROTO_AUTOGEN_1 = `)
// unmarshalKind unmarshals the specified bytes to the specified message kind.
func unmarshalKind(kind, version string, value []byte) (proto.Message, error) {
	doUnmarshal := func(msg proto.Message) (proto.Message, error) {
		if err := proto.Unmarshal(value, msg); err != nil {
			return nil, err
		}
		return msg, nil
	}
	kindVersion := kind + "/" + version
	switch kindVersion {
	default:
		return nil, errors.New("unrecognized message kind/version: " + kindVersion)
`

// Autogenerated code template.
const _PROTO_AUTOGEN_2 = `	}
}
// marshalKind marshals the specified message to a slice of bytes with the kind and version.
func marshalKind(msg proto.Message) (kind, version string, bytes []byte, err error) {
	doMarshal := func(kind, version string, msg proto.Message) (string, string, []byte, error) {
		if bytes, err := proto.Marshal(msg); err != nil {
			return "", "", nil, err
		} else {
			return kind, version, bytes, nil
		}
	}
	switch msg.(type) {
	default:
		return "", "", nil, errors.New("unrecognized message type")
`

// Autogenerated code template.
const _PROTO_AUTOGEN_3 = `	}
}
`

// Stores information about the types for a single package.
type protoPackageTypeInfo struct {
	PackageName  string
	Version      string
	GoImportName string
	GoImportPath string
	TypeNames    []string
}

// protogen walks the api source tree and auto-generates all protocol buffer source
// files in the correct locations, overwriting any existing files. Exits with
// error on failure.
func protogen(ctxt *CodegenContext) {
	if stdOut, stdErr, err := exe.Doexec("", "go", "install", "github.com/gogo/protobuf/protoc-gen-gogo"); err != nil {
		exe.Fatal("installing protoc-gen-gogo", exe.ErrOutput(stdOut, stdErr, err), ctxt.ExeContext)
	}

	apiProtoDir := filepath.Clean(filepath.Join(ctxt.SrcRootDir, "pkg", "api"))
	gogoprotobufDir := ""
	protobufDir := ""
	if dir, err := exe.FindPackageModDir("github.com/gogo/protobuf"); err != nil {
		exe.Fatal("finding gogoprotobufDir", err, ctxt.ExeContext)
	} else {
		gogoprotobufDir = filepath.Clean(dir)
		protobufDir = filepath.Join(dir, "protobuf") // Standard Google includes.
	}

	descOutDir := filepath.Clean(filepath.Join(ctxt.SrcRootDir, "workspace", "desc"))
	if err := os.MkdirAll(descOutDir, 0755); err != nil {
		exe.Fatal("making desc output dir", err, ctxt.ExeContext)
	}

	outStr := "--gogo_out=plugins=grpc,paths=source_relative,"
	outStr += "Mgoogle/protobuf/any.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/api.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/descriptor.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/duration.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/empty.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/field_mask.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/source_context.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/struct.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/timestamp.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/type.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/protobuf/wrappers.proto=github.com/gogo/protobuf/types,"
	outStr += "Mgoogle/api/annotations.proto=github.com/gogo/googleapis/google/api:."
	baseArgs := []string{"-I=.", "-I=" + apiProtoDir, "-I=" + gogoprotobufDir, "-I=" + protobufDir, outStr}

	runProtoc := func(pbFile string, wg *sync.WaitGroup, chPackageTypeInfo chan<- *protoPackageTypeInfo) {
		wg.Add(1)
		importName, importPath := protoPathToImports(pbFile)
		version := string(importName[strings.LastIndex(importName, "_")+1:])
		descFile := filepath.Clean(filepath.Join(descOutDir, importName+".pb"))
		args := append(baseArgs, "--descriptor_set_out="+descFile)
		args = append(args, pbFile)
		if stdOut, stdErr, err := exe.Doexec("", "protoc", args...); err != nil {
			exe.Fatal("compiling protobuf", exe.ErrOutput(stdOut, stdErr, err), ctxt.ExeContext)
		} else {
			fmt.Println(pbFile)
		}
		desc := &descriptor.FileDescriptorSet{}
		if data, err := os.ReadFile(descFile); err != nil {
			exe.Fatal("reading protobuf desc", err, ctxt.ExeContext)
		} else if err = proto.Unmarshal(data, desc); err != nil {
			exe.Fatal("unmarshaling protobuf desc", err, ctxt.ExeContext)
		}
		var typeNames []string
		var packageName string
		for _, f := range desc.File {
			packageName = *f.Package
			for _, msgType := range f.MessageType {
				typeNames = append(typeNames, *msgType.Name)
			}
		}
		chPackageTypeInfo <- &protoPackageTypeInfo{
			PackageName:  packageName,
			Version:      version,
			GoImportName: importName,
			GoImportPath: importPath,
			TypeNames:    typeNames,
		}
		wg.Done()
	}

	wg := &sync.WaitGroup{}
	chPackageTypeInfo := make(chan *protoPackageTypeInfo, _MAX_PROTO_PACKAGES)
	filepath.WalkDir(filepath.Join(ctxt.SrcRootDir, "pkg", "api"), func(pathname string, d fs.DirEntry, err error) error {
		if !d.Type().IsRegular() || !strings.HasSuffix(pathname, ".proto") {
			return nil
		}
		pbFile := strings.Trim(strings.TrimPrefix(pathname, ctxt.SrcRootDir), "/\\")
		pbFile = "./" + strings.ReplaceAll(pbFile, "\\", "/")
		runProtoc(pbFile, wg, chPackageTypeInfo)
		return nil
	})
	wg.Wait()
	close(chPackageTypeInfo)
	os.RemoveAll(descOutDir)

	protoGenerateMarshaling(chPackageTypeInfo, ctxt)
}

// protoPathToImports converts the specified relative .proto path into a Go import name and path.
func protoPathToImports(protoPath string) (string, string) {
	name := path.Dir(strings.TrimPrefix(protoPath, "./pkg/api/"))
	path := "alt-os/api/" + name
	name = "api_" + strings.ReplaceAll(name, "/", "_")
	return name, path
}

// protoGenerateMarshaling consumes the package type info from the specified channel and writes an
// autogenerated go file to the api package for protobuf message marshaling/unmarshaling.
func protoGenerateMarshaling(chPackageTypeInfo <-chan *protoPackageTypeInfo, ctxt *CodegenContext) {
	var infos []*protoPackageTypeInfo
	for info := range chPackageTypeInfo {
		infos = append(infos, info)
	}

	outFilename := filepath.Clean(filepath.Join(ctxt.SrcRootDir, "pkg", "api", "zmarshaling.go"))
	if f, err := os.Create(outFilename); err != nil {
		exe.Fatal("creating "+outFilename, err, ctxt.ExeContext)
	} else {
		f.WriteString(_PROTO_AUTOGEN_0)
		for _, info := range infos {
			f.WriteString(fmt.Sprintf("\t%s \"%s\"\n", info.GoImportName, info.GoImportPath))
		}
		f.WriteString(_PROTO_AUTOGEN_1)
		for _, info := range infos {
			for _, typeName := range info.TypeNames {
				f.WriteString(fmt.Sprintf("\tcase \"api.%s.%s/%s\":\n", info.PackageName, typeName, info.Version))
				f.WriteString(fmt.Sprintf("\t\treturn doUnmarshal(&%s.%s{})\n",
					info.GoImportName, typeName))
			}
		}
		f.WriteString(_PROTO_AUTOGEN_2)
		for _, info := range infos {
			for _, typeName := range info.TypeNames {
				f.WriteString(fmt.Sprintf("\tcase *%s.%s:\n", info.GoImportName, typeName))
				f.WriteString(fmt.Sprintf("\t\treturn doMarshal(\"api.%s.%s\", \"%s\", msg)\n",
					info.PackageName, typeName, info.Version))
			}
		}
		f.WriteString(_PROTO_AUTOGEN_3)
		f.Close()
	}

	if stdOut, stdErr, err := exe.Doexec("", "gofmt", "-w", outFilename); err != nil {
		exe.Fatal("formatting "+outFilename, exe.ErrOutput(stdOut, stdErr, err), ctxt.ExeContext)
	}
}
